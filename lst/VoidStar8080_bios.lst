     1     			TITLE	'Customized CP/M 2.2 Bios for the (void *)8080 Simulated Microcomputer'
     2
     3      00 30	msize	equ	48		;cp/m version memory size in kilobytes
     4
     5 			;	"bias" is address offset from 3400h for memory systems larger
     6 			;	than 20k (referred to as "b" throughout the text)
     7 			;
     8      70 00	bias	equ	(msize-20)*1024
     9      A4 00	ccp	equ	3400h+bias	;base of ccp
    10      AC 06	bdos	equ	ccp+806h	;base of bdos
    11      BA 00	bios	equ	ccp+1600h	;base of bios
    12      BD 00	bioslim	equ     ccp+1900H       ;end of data loaded from disk
    13      03 00	uimem	equ	(msize*1024)-bioslim
    14
    15 			; page zero locations
    16      00 04	cdisk	equ	0004h		;current disk number 0=a,... l5=p
    17      00 03	iobyte	equ	0003h		;intel i/o byte
    18 			;
    19      BA 00		org	bios		;origin of this program
    20      00 2C	nsects	equ	($-ccp)/128	;warm start sector count
    21 			;
    22 			;	jump vector for individual subroutines
    23 			;
    24 BA00 C3 9C BA		jmp	boot	;cold start
    25 BA03 C3 A6 BA	wboote:	jmp	wboot	;warm start
    26 BA06 C3 11 BB		jmp	const	;console status
    27 BA09 C3 19 BB		jmp	conin	;console character in
    28 BA0C C3 25 BB		jmp	conout	;console character out
    29 BA0F C3 30 BB		jmp	list	;list character out
    30 BA12 C3 43 BB		jmp	punch	;punch character out
    31 BA15 C3 4E BB		jmp	reader	;reader character out
    32 BA18 C3 5A BB		jmp	home	;move head to home position
    33 BA1B C3 60 BB		jmp	seldsk	;select disk
    34 BA1E C3 77 BB		jmp	settrk	;set track number
    35 BA21 C3 7B BB		jmp	setsec	;set sector number
    36 BA24 C3 85 BB		jmp	setdma	;set dma address
    37 BA27 C3 8B BB		jmp	read	;read disk
    38 BA2A C3 9A BB		jmp	write	;write disk
    39 BA2D C3 3B BB		jmp	listst	;return list status
    40 BA30 C3 7F BB		jmp	sectran	;sector translate
    41 			;
    42 			;	fixed data tables for four-drive standard
    43 			;	ibm-compatible 8-inch disks
    44 			;
    45 			;	disk Parameter header for disk 00
    46 BA33		dpbase:	dw	trans, 0000h
            73BA 0000 
    47 BA37			dw	0000h, 0000h
            0000 0000 
    48 BA3B			dw	dirbf, dpblk
            02BD 8DBA 
    49 BA3F			dw	chk00, all00
            FEBD 82BD 
    50 			;	disk parameter header for disk 01
    51 BA43			dw	trans, 0000h
            73BA 0000 
    52 BA47			dw	0000h, 0000h
            0000 0000 
    53 BA4B			dw	dirbf, dpblk
            02BD 8DBA 
    54 BA4F			dw	chk01, all01
            0EBE A1BD 
    55 			;	disk parameter header for disk 02
    56 BA53			dw	trans, 0000h
            73BA 0000 
    57 BA57			dw	0000h, 0000h
            0000 0000 
    58 BA5B			dw	dirbf, dpblk
            02BD 8DBA 
    59 BA5F			dw	chk02, all02
            1EBE C0BD 
    60 			;	disk parameter header for disk 03
    61 BA63			dw	trans, 0000h
            73BA 0000 
    62 BA67			dw	0000h, 0000h
            0000 0000 
    63 BA6B			dw	dirbf, dpblk
            02BD 8DBA 
    64 BA6F			dw	chk03, all03
            2EBE DFBD 
    65 			;
    66 			;	sector translate vector
    67 BA73		trans:	db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
            01 07 0D 13 
            
    68 BA77			db	25,  5, 11, 17	;sectors  5,  6,  7,  6
            19 05 0B 11 
            
    69 BA7B			db	23,  3,  9, 15	;sectors  9, 10, 11, 12
            17 03 09 0F 
            
    70 BA7F			db	21,  2,  8, 14	;sectors 13, 14, 15, 16
            15 02 08 0E 
            
    71 BA83			db	20, 26,  6, 12	;sectors 17, 18, 19, 20
            14 1A 06 0C 
            
    72 BA87			db	18, 24,  4, 10	;sectors 21, 22, 23, 24
            12 18 04 0A 
            
    73 BA8B			db	16, 22		;sectors 25, 26
            10 16 
    74 			;
    75 			dpblk:	;disk parameter block, common to all disks
    76 BA8D			dw	26		;sectors per track
            1A00 
    77 BA8F			db	3		;block shift factor
            03 
    78 BA90			db	7		;block mask
            07 
    79 BA91			db	0		;null mask
            00 
    80 BA92			dw	242		;disk size-1
            F200 
    81 BA94			dw	63		;directory max
            3F00 
    82 BA96			db	192		;alloc 0
            C0 
    83 BA97			db	0		;alloc 1
            00 
    84 BA98			dw	16		;check size
            1000 
    85 BA9A			dw	2		;track offset
            0200 
    86 			;
    87 			;	end of fixed tables
    88 			;
    89 			;	individual subroutines to perform each function
    90 			boot:	;simplest case is to just perform parameter initialization
    91 BA9C AF			xra	a		;zero in the accum
    92 BA9D 32 03 00		sta	iobyte		;clear the iobyte
    93 BAA0 32 04 00		sta	cdisk		;select disk zero
    94 BAA3 C3 EF BA		jmp	gocpm		;initialize and go to cp/m
    95 			;
    96 			wboot:	;simplest case is to read the disk until all sectors loaded
    97 BAA6 31 80 00		lxi	sp, 80h		;use space below buffer for stack
    98 BAA9 0E 00		mvi	c, 0		;select disk 0
    99 BAAB CD 60 BB		call	seldsk
   100 BAAE CD 5A BB		call	home		;go to track 00
   101 			;
   102 BAB1 06 2C		mvi	b, nsects	;b counts * of sectors to load
   103 BAB3 0E 00		mvi	c, 0		;c has the current track number
   104 BAB5 16 02		mvi	d, 2		;d has the next sector to read
   105 			;	note that we begin by reading track 0, sector 2 since sector 1
   106 			;	contains the cold start loader, which is skipped in a warm start
   107 BAB7 21 00 A4		lxi	h, ccp		;base of cp/m (initial load point)
   108 			load1:	;load	one more sector
   109 BABA C5			push	b		;save sector count, current track
   110 BABB D5			push	d		;save next sector to read
   111 BABC E5			push	h		;save dma address
   112 BABD 4A			mov	c, d		;get sector address to register C
   113 BABE CD 7B BB		call	setsec		;set sector address from register C
   114 BAC1 C1			pop	b		;recall dma address to b, C
   115 BAC2 C5			push	b		;replace on stack for later recall
   116 BAC3 CD 85 BB		call	setdma		;set dma address from b, C
   117 			;
   118 			;	drive set to 0, track set, sector set, dma address set
   119 BAC6 CD 8B BB		call	read
   120 BAC9 FE 00		cpi	00h		;any errors?
   121 BACB C2 A6 BA		jnz	wboot		;retry the entire boot if an error occurs
   122 			;
   123 			;	no error, move to next sector
   124 BACE E1			pop	h		;recall dma address
   125 BACF 11 80 00		lxi	d, 128		;dma=dma+128
   126 BAD2 19			dad	d		;new dma address is in h, l
   127 BAD3 D1			pop	d		;recall sector address
   128 BAD4 C1			pop	b	;recall number of sectors remaining, and current trk
   129 BAD5 05			dcr	b		;sectors=sectors-1
   130 BAD6 CA EF BA		jz	gocpm		;transfer to cp/m if all have been loaded
   131 			;
   132 			;	more	sectors remain to load, check for track change
   133 BAD9 14			inr	d
   134 BADA 7A			mov	a,d		;sector=27?, if so, change tracks
   135 BADB FE 1B		cpi	27
   136 BADD DA BA BA		jc	load1		;carry generated if sector<27
   137 			;
   138 			;	end of	current track,	go to next track
   139 BAE0 16 01		mvi	d, 1		;begin with first sector of next track
   140 BAE2 0C			inr	c		;track=track+1
   141 			;
   142 			;	save	register state, and change tracks
   143 BAE3 C5			push	b
   144 BAE4 D5			push	d
   145 BAE5 E5			push	h
   146 BAE6 CD 77 BB		call	settrk		;track address set from register c
   147 BAE9 E1			pop	h
   148 BAEA D1			pop	d
   149 BAEB C1			pop	b
   150 BAEC C3 BA BA		jmp	load1		;for another sector
   151 			;
   152 			;	end of	load operation, set parameters and go to cp/m
   153 			gocpm:
   154 BAEF 3E C3		mvi	a, 0c3h		;c3 is a jmp instruction
   155 BAF1 32 00 00		sta	0		;for jmp to wboot
   156 BAF4 21 03 BA		lxi	h, wboote	;wboot entry point
   157 BAF7 22 01 00		shld	1		;set address field for jmp at 0
   158 			;
   159 BAFA 32 05 00		sta	5		;for jmp to bdos
   160 BAFD 21 06 AC		lxi	h, bdos		;bdos entry point
   161 BB00 22 06 00		shld	6		;address field of Jump at 5 to bdos
   162 			;
   163 BB03 01 80 00		lxi	b, 80h		;default dma address is 80h
   164 BB06 CD 85 BB		call	setdma
   165 			;
   166 BB09 FB			ei			;enable the interrupt system
   167 BB0A 3A 04 00		lda	cdisk		;get current disk number
   168 BB0D 4F			mov	c, a		;send to the ccp
   169 BB0E C3 00 A4		jmp	ccp		;go to cp/m for further processing
   170
   171 			;;; === === === === === === === === === === === === === === === ===
   172 			;;;	simple i/o handlers (must be filled in by user)
   173 			;;;	in each case, the entry point is provided, with space reserved
   174 			;;;	to insert your own code
   175 			;;; === === === === === === === === === === === === === === === ===
   176
   177 			;;; === === === === === === === === === === === === === === === ===
   178 			;;; serial device i/o ports
   179 			;;; === === === === === === === === === === === === === === === ===
   180
   181      00 00	ttyd	equ     0               ;read/write data from/to printing console
   182      00 01	ttyc	equ     1               ;printing console status/control port
   183
   184      00 02	crtd	equ     2               ;read/write data from/to video console
   185      00 03	crtc	equ     3               ;video console status/control port
   186
   187      00 04	lptd	equ     4               ;write data to line printer
   188      00 05	lptc	equ     5               ;line printer status/control port
   189
   190      00 06	pptd	equ     6               ;read/write data from/to paper tape
   191      00 07	pptc	equ     7               ;paper tape status/control port
   192
   193 			;;; === === === === === === === === === === === === === === === ===
   194 			;;; Return FF if a byte is available on CON: or 00 if not.
   195 			;;; No I/O byte support yet
   196 			;;; === === === === === === === === === === === === === === === ===
   197
   198 			const:
   199 BB11 DB 01	        in      ttyc
   200 BB13 E6 02	        ani     02h
   201 BB15 C8		        rz
   202 BB16 3E FF	        mvi     a,0ffh
   203 BB18 C9		        ret
   204
   205 			;;; === === === === === === === === === === === === === === === ===
   206 			;;; get next character from con: into a and clear its parity bit.
   207 			;;; if there is no data available, wait for some.
   208 			;;; no i/o byte support yet
   209 			;;; === === === === === === === === === === === === === === === ===
   210
   211 			conin:
   212 BB19 DB 01	        in      ttyc
   213 BB1B E6 01	        ani     01h
   214 BB1D CA 19 BB	        jz      conin
   215 BB20 DB 00	        in      ttyd
   216 BB22 E6 7F	        ani     7fh
   217 BB24 C9		        ret
   218
   219
   220 			;;; === === === === === === === === === === === === === === === ===
   221 			;;; put the the character in c to con: 
   222 			;;; if the device can not accept data, wait until it can.
   223 			;;; modifies the content of register a.
   224 			;;; no i/o byte support yet
   225 			;;; === === === === === === === === === === === === === === === ===
   226
   227 			conout:
   228 BB25 DB 01	        in      ttyc
   229 BB27 E6 01	        ani     01h
   230 BB29 CA 25 BB	        jz      conout
   231 BB2C 79		        mov     a,c
   232 BB2D D3 00	        out     ttyd
   233 BB2F C9		        ret
   234
   235 			;;; === === === === === === === === === === === === === === === ===
   236 			;;; put the the character in c to lst: 
   237 			;;; if the device can not accept data, wait until it can.
   238 			;;; modifies the content of register a.
   239 			;;; no i/o byte support yet
   240 			;;; === === === === === === === === === === === === === === === ===
   241
   242 			list:
   243 BB30 DB 05	        in      lptc
   244 BB32 E6 01	        ani     01h
   245 BB34 CA 30 BB	        jz      list
   246 BB37 79		        mov     a,c
   247 BB38 D3 04	        out     lptd
   248 BB3A C9		        ret
   249
   250 			;;; === === === === === === === === === === === === === === === ===
   251 			;;; return ff if lst: can accept a byte or 00 if not.
   252 			;;; no i/o byte support yet
   253 			;;; === === === === === === === === === === === === === === === ===
   254
   255 			listst:
   256 BB3B DB 05	        in      lptc
   257 BB3D E6 04	        ani     04h
   258 BB3F C8		        rz
   259 BB40 3E FF	        mvi     a,0ffh
   260 BB42 C9		        ret
   261
   262 			;;; === === === === === === === === === === === === === === === ===
   263 			;;; put the the character in c to pun: 
   264 			;;; if the device can not accept data, wait until it can.
   265 			;;; modifies the content of register a.
   266 			;;; no i/o byte support yet
   267 			;;; === === === === === === === === === === === === === === === ===
   268
   269 			punch:
   270 BB43 DB 07	        in      pptc
   271 BB45 E6 01	        ani     01h
   272 BB47 CA 43 BB	        jz      punch
   273 BB4A 79		        mov     a,c
   274 BB4B D3 06	        out     pptd
   275 BB4D C9		        ret
   276
   277 			;;; === === === === === === === === === === === === === === === ===
   278 			;;; get next character from rdr: into a and clear its parity bit.
   279 			;;; if there is no data available, wait for some.
   280 			;;; no i/o byte support yet
   281 			;;; === === === === === === === === === === === === === === === ===
   282
   283 			reader:
   284 BB4E DB 07	        in      pptc
   285 BB50 E6 01	        ani     01h
   286 BB52 CA 4E BB	        jz      reader
   287 BB55 DB 06	        in      pptd
   288 BB57 E6 7F		ani	7fh		;remember to strip parity bit
   289 BB59 C9			ret
   290
   291 			;;; === === === === === === === === === === === === === === === ===
   292 			;;;	i/o drivers for the disk follow
   293 			;;;	for now, we will simply store the parameters away for use
   294 			;;;	in the read and write subroutines
   295 			;;; === === === === === === === === === === === === === === === ===
   296
   297 			;;; === === === === === === === === === === === === === === === ===
   298 			;;; disk controller i/o ports
   299 			;;; === === === === === === === === === === === === === === === ===
   300
   301      00 0A	bdres	equ	10              ;reset controller (drv 0, trk 0, sec 1)
   302      00 0B	bddrv	equ	11              ;select drive
   303      00 0C	bdtrk	equ	12              ;select track
   304      00 0D	bdsec	equ	13              ;select sector
   305      00 0E	bddat	equ	14              ;read/write next byte
   306
   307 			;;; === === === === === === === === === === === === === === === ===
   308 			;;; return the disk head of the currently selected disk (initially
   309 			;;; disk a) to the track 00 position. if your controller allows
   310 			;;; access to the track 0 flag from the device, step the head until
   311 			;;; the track 0 flag is detected. if your controller does not
   312 			;;; support this feature, you can translate the home call into a
   313 			;;; call on settrk with a parameter of 0.
   314 			;;; === === === === === === === === === === === === === === === ===
   315
   316 			home:
   317 BB5A 0E 00	        mvi     c,0
   318 BB5C CD 77 BB	        call    settrk
   319 BB5F C9		        ret
   320
   321
   322 			;;; === === === === === === === === === === === === === === === ===
   323 			;;; select the disk drive given by register c for further opera-
   324 			;;; tions, where register c contains 0 for drive a, 1 for drive b,
   325 			;;; 2 for drive c, and 3 for drive d. (the standard cp/m
   326 			;;; distribution supports a maximum of four drives). if
   327 			;;; your system has less than 4 drives, you may wish to give an
   328 			;;; error message at the console, and terminate execution. it is
   329 			;;; advisable to postpone the actual disk operation until
   330 			;;; an i/o function (seek, read or write) is actually performed,
   331 			;;; since disk selects often occur without ultimately performing
   332 			;;; any disk i/o, and many controllers will unload the head of the
   333 			;;; current disk before selecting the new drive. this would
   334 			;;; cause an excessive amount of noise and disk wear.
   335 			;;;
   336 			;;; voidstar8080: this call resets the controller, in case a previous
   337 			;;; read or write operation did not complete properly. This is a "soft"
   338 			;;; reset; the disk array (real or simulated) state is not modified
   339 			;;; until we actually initiate a read or write.
   340 			;;;
   341 			;;; CP/M 2.2: locate and return the DPB for this drive in HL,
   342 			;;; or set HL to 0000h if the drive is not within our DPB table.
   343 			;;; === === === === === === === === === === === === === === === ===
   344 			seldsk:
   345 BB60 21 00 00		lxi	h, 0000h	;error return code
   346 BB63 79			mov	a, c
   347 BB64 D3 0A	        out     bdres           ;reset bdev controller
   348 BB66 D3 0B	        out     bddrv           ;select bdev drive number
   349
   350 BB68 FE 04		cpi	4		;must be between 0 and 3
   351 BB6A D0			rnc			;no carry if 4, 5,...
   352 			;	disk number is in the proper range
   353
   354 			;	compute proper disk Parameter header address
   355 BB6B 6F			mov	l, a		;l=disk number 0, 1, 2, 3
   356 BB6C 26 00		mvi	h, 0		;high order zero
   357 BB6E 29			dad	h		;*2
   358 BB6F 29			dad	h		;*4
   359 BB70 29			dad	h		;*8
   360 BB71 29			dad	h		;*16 (size of each header)
   361 BB72 11 33 BA		lxi	d, dpbase
   362 BB75 19			dad	d		;hl=.dpbase (diskno*16)
   363 BB76 C9			ret
   364
   365 			;;; === === === === === === === === === === === === === === === ===
   366 			;;; register c contains the track number for subsequent disk
   367 			;;; accesses on the currently selected drive. you can choose to
   368 			;;; seek the selected track at this time, or delay the seek until
   369 			;;; the next read or write actually occurs. register c can take
   370 			;;; on values in the range 0-76 corresponding to valid track
   371 			;;; numbers.
   372 			;;;
   373 			;;; voidstar8080: pass the track number along to the controller.
   374 			;;; === === === === === === === === === === === === === === === ===
   375
   376 			settrk:
   377 BB77 79			mov	a, c
   378 BB78 D3 0C	        out     bdtrk
   379 BB7A C9			ret
   380
   381 			;;; === === === === === === === === === === === === === === === ===
   382 			;;; register c contains the sector number (1 through 26) for sub-
   383 			;;; sequent disk accesses on the currently selected drive. you
   384 			;;; can choose to send this information to the controller at this
   385 			;;; point, or instead delay sector selectino until a read
   386 			;;; or write opration occurs.
   387 			;;; === === === === === === === === === === === === === === === ===
   388
   389 			setsec:
   390 BB7B 79		        mov     a,c
   391 BB7C D3 0D	        out     bdsec
   392 BB7E C9		        ret
   393
   394 			;;; === === === === === === === === === === === === === === === ===
   395 			;;; translate the sector given by bc using the
   396 			;;; translate table given by de
   397 			;;; === === === === === === === === === === === === === === === ===
   398
   399 			sectran:
   400 BB7F EB			xchg			;hl=.trans
   401 BB80 09			dad	b		;hl=.trans (sector)
   402 BB81 6E			mov	l, m		;l=trans (sector)
   403 BB82 26 00		mvi	h, 0		;hl=trans (sector)
   404 BB84 C9			ret			;with value in hl
   405
   406 			;;; === === === === === === === === === === === === === === === ===
   407 			;;; registers b and c (high-order 8 bits in b, low-order 8 bits
   408 			;;; in c) contain the dma (direct memory access) address for sub-
   409 			;;; sequent read or write operations. for example, if b = 00h
   410 			;;; and c = 80h when setdma is called, then all subsequent read
   411 			;;; operations read their data into 80h through 0ffh, and all
   412 			;;; subsequent write operations get their data from 80h through
   413 			;;; 0ffh, until the next call to setdma occurs. the initial
   414 			;;; dma address is assumed to be 80h. note that the controller
   415 			;;; need not actually support direct memory access. if, for
   416 			;;; example, all data is received and sent through i/o ports, the
   417 			;;; cbios which you construct will use he 128-byte area starting
   418 			;;; at the selected dma address for the memory buffer during the
   419 			;;; following read or write operations.
   420 			;;; === === === === === === === === === === === === === === === ===
   421
   422 			setdma:
   423 BB85 69			mov	l, c		;low order address
   424 BB86 60			mov	h, b		;high order address
   425 BB87 22 00 BD		shld	dmaad		;save the address
   426 BB8A C9			ret
   427
   428 			;;; === === === === === === === === === === === === === === === ===
   429 			;;; assuming the drive has been selected, the track has been set,
   430 			;;; the sector has been set, and the dma address has been speci-
   431 			;;; fied, the read subroutine attempts to read one sector based
   432 			;;; upon these parameters, and returns the following error codes
   433 			;;; in register a:
   434 			;;;
   435 			;;;            0      no errors occurred
   436 			;;;            1      non-recoverable error condition occurred
   437 			;;;
   438 			;;; currently, cp/m responds only to a zero or non-zero value as
   439 			;;; the return code. that is, if the value in register a is 0
   440 			;;; then cp/m assumes that the disk operation completed properly.
   441 			;;; if an error occurs, however, the cbios should attempt at
   442 			;;; least 10 re-tries to see if the error is recoverable. when an
   443 			;;; error is reported the bdos will print the message "bdos err
   444 			;;; on x: bad sector." the operator then has the option of
   445 			;;; typing <cr> to ignore the error, or control-c to abort.
   446 			;;; === === === === === === === === === === === === === === === ===
   447 			read:   
   448 BB8B 2A 00 BD	        lhld    dmaad
   449 BB8E 0E 80	        mvi     c,128
   450 			readl:
   451 BB90 DB 0E	        in      bddat
   452 BB92 77		        mov     m,a
   453 BB93 23		        inx     hl
   454 BB94 0D		        dcr     c
   455 BB95 C2 90 BB	        jnz     readl
   456 BB98 AF		        xra     a
   457 BB99 C9		        ret
   458
   459 			;;; === === === === === === === === === === === === === === === ===
   460 			;;; write the data from the currently selected dma address to the
   461 			;;; currently selected drive, track, and sector. the data should
   462 			;;; be marked as "non deleted data" to maintain compatibility
   463 			;;; with other cp/m systems. the error codes given in the read
   464 			;;; command are returned in register a, with error recovery at-
   465 			;;; tempts as described above.
   466 			;;; === === === === === === === === === === === === === === === ===
   467 			write:  
   468 BB9A 2A 00 BD	        lhld    dmaad
   469 BB9D 0E 80	        mvi     c,128
   470 			writel:
   471 BB9F 7E		        mov     a,m
   472 BBA0 D3 0E	        out     bddat
   473 BBA2 23		        inx     hl
   474 BBA3 0D		        dcr     c
   475 BBA4 C2 9F BB	        jnz     writel
   476 BBA7 AF		        xra     a
   477 BBA8 C9		        ret
   478
   479      BB A9	endbios	equ	$
   480
   481 			;;; === === === === === === === === === === === === === === === ===
   482 			;	the remainder of the cbios is reserved uninitialized
   483 			;	data area, and does not need to be a part of the
   484 			;	system memory image (the space must be available,
   485 			;	however, between the BIOS and the end of memory).
   486 			;
   487      BD 00	        org	bioslim
   488 			bss:    	 	;beginning of data area
   489
   490 BD00		dmaad:	ds	2	;direct memory address
   491
   492 BD02		dirbf:	ds	128	;scratch directory area
   493 BD82		all00:	ds	31	;allocation vector 0
   494 BDA1		all01:	ds	31	;allocation vector 1
   495 BDC0		all02:	ds	31	;allocation vector 2
   496 BDDF		all03:	ds	31	;allocation vector 3
   497 BDFE		chk00:	ds	16	;check vector 0
   498 BE0E		chk01:	ds	16	;check vector 1
   499 BE1E		chk02:	ds	16	;check vector 2
   500 BE2E		chk03:	ds	16	;check vector 3
   501 			endbss:			;end of data area
   502 			        
   503      01 A9	bioslen	equ     endbios-bios        
   504      01 57	biosavl	equ	bioslim-endbios	;can add this much to the BIOS segment
   505
   506      01 3E	bsslen	equ	endbss-bss;	;size of bssa area
   507      01 42	bssavl	equ	0280H-bsslen	;can add this much to the BSS segment
   508
   509     			end


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names		Types	Values
-----		-----	------
msize		EQU	00030h
bias		EQU	07000h
ccp		EQU	0A400h
bdos		EQU	0AC06h
bios		EQU	0BA00h
bioslim		EQU	0BD00h
uimem		EQU	00300h
cdisk		EQU	00004h
iobyte		EQU	00003h
nsects		EQU	0002Ch
ttyd		EQU	00000h
ttyc		EQU	00001h
crtd		EQU	00002h
crtc		EQU	00003h
lptd		EQU	00004h
lptc		EQU	00005h
pptd		EQU	00006h
pptc		EQU	00007h
bdres		EQU	0000Ah
bddrv		EQU	0000Bh
bdtrk		EQU	0000Ch
bdsec		EQU	0000Dh
bddat		EQU	0000Eh
endbios		EQU	0BBA9h
bioslen		EQU	001A9h
biosavl		EQU	00157h
bsslen		EQU	0013Eh
bssavl		EQU	00142h
wboote		Label	0BA03h
dpbase		Label	0BA33h
trans		Label	0BA73h
dpblk		Label	0BA8Dh
boot		Label	0BA9Ch
wboot		Label	0BAA6h
load1		Label	0BABAh
gocpm		Label	0BAEFh
const		Label	0BB11h
conin		Label	0BB19h
conout		Label	0BB25h
list		Label	0BB30h
listst		Label	0BB3Bh
punch		Label	0BB43h
reader		Label	0BB4Eh
home		Label	0BB5Ah
seldsk		Label	0BB60h
settrk		Label	0BB77h
setsec		Label	0BB7Bh
sectran		Label	0BB7Fh
setdma		Label	0BB85h
read		Label	0BB8Bh
readl		Label	0BB90h
write		Label	0BB9Ah
writel		Label	0BB9Fh
bss		Label	0BD00h
dmaad		Label	0BD00h
dirbf		Label	0BD02h
all00		Label	0BD82h
all01		Label	0BDA1h
all02		Label	0BDC0h
all03		Label	0BDDFh
chk00		Label	0BDFEh
chk01		Label	0BE0Eh
chk02		Label	0BE1Eh
chk03		Label	0BE2Eh
endbss		Label	0BE3Eh

Statistics
----------
"Name"	= 0
"EQU"	= 28
"SET"	= 0
Labels	= 37


