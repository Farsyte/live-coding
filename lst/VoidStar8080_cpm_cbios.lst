     1     			TITLE	'Customized CP/M 2.2 Bios for the (void *)8080 Simulated Microcomputer'
     2
     3      00 3E	msize	equ	62		;cp/m ram size in kilobytes
     4
     5 			;	"bias" is address offset from 3400h for memory systems larger
     6 			;	than 20k (referred to as "b" throughout the text)
     7 			;
     8      A8 00	bias	equ	(msize-20)*1024
     9      DC 00	ccp	equ	3400h+bias	;base of ccp
    10      E4 06	bdos	equ	ccp+806h	;base of bdos
    11      F2 00	bios	equ	ccp+1600h	;base of bios
    12      F5 00	bioslim	equ     ccp+1900H       ;end of data loaded from disk
    13
    14 			; page zero locations known by BIOS
    15      00 03	iobyte	equ	0003h		;intel i/o byte
    16      00 04	cdisk	equ	0004h		;current disk number 0=a,... l5=p
    17 			;
    18      F2 00		org	bios		;origin of this program
    19      00 2C	nsects	equ	($-ccp)/128	;warm start sector count
    20 			;
    21 			;	jump vector for individual subroutines
    22 			;
    23 F200 C3 9C F2		jmp	boot	;cold start
    24 F203 C3 A6 F2	wboote:	jmp	wboot	;warm start
    25
    26 F206 C3 11 F3		jmp	const	;console status
    27 F209 C3 2E F3		jmp	conin	;console character in
    28 F20C C3 47 F3		jmp	conout	;console character out
    29 F20F C3 60 F3		jmp	list	;list character out
    30 F212 C3 92 F3		jmp	punch	;punch character out
    31 F215 C3 A6 F3		jmp	reader	;reader character out
    32
    33 F218 C3 42 F4		jmp	home	;move head to home position
    34 F21B C3 48 F4		jmp	seldsk	;select disk
    35 F21E C3 5F F4		jmp	settrk	;set track number
    36 F221 C3 63 F4		jmp	setsec	;set sector number
    37 F224 C3 6D F4		jmp	setdma	;set dma address
    38 F227 C3 73 F4		jmp	read	;read disk
    39 F22A C3 82 F4		jmp	write	;write disk
    40
    41 F22D C3 79 F3		jmp	listst	;return list status
    42 F230 C3 67 F4		jmp	sectran	;sector translate
    43 			;
    44 			;	fixed data tables for four standard
    45 			;	ibm-compatible 8-inch diskette drives
    46 			;
    47 			dpbase: 
    48 F233			dw	trans, 0000h, 0000h, 0000h, dirbf, dpblk, chk00, all00
            73F2 0000 0000 
            0000 02F5 8DF2 
            FEF5 82F5 
    49 F243			dw	trans, 0000h, 0000h, 0000h, dirbf, dpblk, chk01, all01
            73F2 0000 0000 
            0000 02F5 8DF2 
            0EF6 A1F5 
    50 F253			dw	trans, 0000h, 0000h, 0000h, dirbf, dpblk, chk02, all02
            73F2 0000 0000 
            0000 02F5 8DF2 
            1EF6 C0F5 
    51 F263			dw	trans, 0000h, 0000h, 0000h, dirbf, dpblk, chk03, all03
            73F2 0000 0000 
            0000 02F5 8DF2 
            2EF6 DFF5 
    52      00 04	ndisk   equ     $-dpbase/16
    53 			;
    54 			;	sector translate vector
    55 F273		trans:	db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
            01 07 0D 13 
            
    56 F277			db	25,  5, 11, 17	;sectors  5,  6,  7,  6
            19 05 0B 11 
            
    57 F27B			db	23,  3,  9, 15	;sectors  9, 10, 11, 12
            17 03 09 0F 
            
    58 F27F			db	21,  2,  8, 14	;sectors 13, 14, 15, 16
            15 02 08 0E 
            
    59 F283			db	20, 26,  6, 12	;sectors 17, 18, 19, 20
            14 1A 06 0C 
            
    60 F287			db	18, 24,  4, 10	;sectors 21, 22, 23, 24
            12 18 04 0A 
            
    61 F28B			db	16, 22		;sectors 25, 26
            10 16 
    62 			;
    63 			dpblk:	;disk parameter block, common to all disks
    64 F28D			dw	26		;sectors per track
            1A00 
    65 F28F			db	3		;block shift factor
            03 
    66 F290			db	7		;block mask
            07 
    67 F291			db	0		;null mask
            00 
    68 F292			dw	242		;disk size-1
            F200 
    69 F294			dw	63		;directory max
            3F00 
    70 F296			db	192		;alloc 0
            C0 
    71 F297			db	0		;alloc 1
            00 
    72 F298			dw	16		;check size
            1000 
    73 F29A			dw	2		;track offset
            0200 
    74 			;
    75 			;	end of fixed tables
    76 			;
    77 			;	individual subroutines to perform each function
    78 			boot:	;simplest case is to just perform parameter initialization
    79 F29C AF			xra	a		;zero in the accum
    80 F29D 32 03 00		sta	iobyte		;clear the iobyte
    81 F2A0 32 04 00		sta	cdisk		;select disk zero
    82 F2A3 C3 EF F2		jmp	gocpm		;initialize and go to cp/m
    83 			;
    84 			wboot:	;simplest case is to read the disk until all sectors loaded
    85 F2A6 31 80 00		lxi	sp, 80h		;use space below buffer for stack
    86 F2A9 0E 00		mvi	c, 0		;select disk 0
    87 F2AB CD 48 F4		call	seldsk
    88 F2AE CD 42 F4		call	home		;go to track 00
    89 			;
    90 F2B1 06 2C		mvi	b, nsects	;b counts * of sectors to load
    91 F2B3 0E 00		mvi	c, 0		;c has the current track number
    92 F2B5 16 02		mvi	d, 2		;d has the next sector to read
    93 			;	note that we begin by reading track 0, sector 2 since sector 1
    94 			;	contains the cold start loader, which is skipped in a warm start
    95 F2B7 21 00 DC		lxi	h, ccp		;base of cp/m (initial load point)
    96 			load1:	;load	one more sector
    97 F2BA C5			push	b		;save sector count, current track
    98 F2BB D5			push	d		;save next sector to read
    99 F2BC E5			push	h		;save dma address
   100 F2BD 4A			mov	c, d		;get sector address to register C
   101 F2BE CD 63 F4		call	setsec		;set sector address from register C
   102 F2C1 C1			pop	b		;recall dma address to b, C
   103 F2C2 C5			push	b		;replace on stack for later recall
   104 F2C3 CD 6D F4		call	setdma		;set dma address from b, C
   105 			;
   106 			;	drive set to 0, track set, sector set, dma address set
   107 F2C6 CD 73 F4		call	read
   108 F2C9 FE 00		cpi	00h		;any errors?
   109 F2CB C2 A6 F2		jnz	wboot		;retry the entire boot if an error occurs
   110 			;
   111 			;	no error, move to next sector
   112 F2CE E1			pop	h		;recall dma address
   113 F2CF 11 80 00		lxi	d, 128		;dma=dma+128
   114 F2D2 19			dad	d		;new dma address is in h, l
   115 F2D3 D1			pop	d		;recall sector address
   116 F2D4 C1			pop	b	;recall number of sectors remaining, and current trk
   117 F2D5 05			dcr	b		;sectors=sectors-1
   118 F2D6 CA EF F2		jz	gocpm		;transfer to cp/m if all have been loaded
   119 			;
   120 			;	more	sectors remain to load, check for track change
   121 F2D9 14			inr	d
   122 F2DA 7A			mov	a,d		;sector=27?, if so, change tracks
   123 F2DB FE 1B		cpi	27
   124 F2DD DA BA F2		jc	load1		;carry generated if sector<27
   125 			;
   126 			;	end of	current track,	go to next track
   127 F2E0 16 01		mvi	d, 1		;begin with first sector of next track
   128 F2E2 0C			inr	c		;track=track+1
   129 			;
   130 			;	save	register state, and change tracks
   131 F2E3 C5			push	b
   132 F2E4 D5			push	d
   133 F2E5 E5			push	h
   134 F2E6 CD 5F F4		call	settrk		;track address set from register c
   135 F2E9 E1			pop	h
   136 F2EA D1			pop	d
   137 F2EB C1			pop	b
   138 F2EC C3 BA F2		jmp	load1		;for another sector
   139 			;
   140 			;	end of	load operation, set parameters and go to cp/m
   141 			gocpm:
   142 F2EF 3E C3		mvi	a, 0c3h		;c3 is a jmp instruction
   143 F2F1 32 00 00		sta	0		;for jmp to wboot
   144 F2F4 21 03 F2		lxi	h, wboote	;wboot entry point
   145 F2F7 22 01 00		shld	1		;set address field for jmp at 0
   146 			;
   147 F2FA 32 05 00		sta	5		;for jmp to bdos
   148 F2FD 21 06 E4		lxi	h, bdos		;bdos entry point
   149 F300 22 06 00		shld	6		;address field of Jump at 5 to bdos
   150 			;
   151 F303 01 80 00		lxi	b, 80h		;default dma address is 80h
   152 F306 CD 6D F4		call	setdma
   153 			;
   154 F309 FB			ei			;enable the interrupt system
   155 F30A 3A 04 00		lda	cdisk		;get current disk number
   156 F30D 4F			mov	c, a		;send to the ccp
   157 F30E C3 00 DC		jmp	ccp		;go to cp/m for further processing
   158
   159 			;;; === === === === === === === === === === === === === === === ===
   160 			;;; CDEV selection using IOBYTE
   161 			;;; === === === === === === === === === === === === === === === ===
   162
   163 				;; === === === === === === === === === === === ===
   164 				;; return ff if a byte is available on con: or 00 if not.
   165 				;; use i/o byte to determine which device is the console.
   166 			        ;; switch i/o byte to "pure TTY" if an invalid device is selected
   167 				;; === === === === === === === === === === === ===
   168 			const:
   169 F311 3A 03 00	        lda     iobyte
   170 F314 E6 03	        ani     03h
   171 F316 CA BA F3	        jz      ttyrdy
   172 F319 FE 01	        cpi     1
   173 F31B CA E1 F3	        jz      crtrdy
   174 F31E FE 02	        cpi     2
   175 F320 CA 08 F4	        jz      pptrdy
   176 				;; no support for user defined consoles (yet?)
   177 				;; switch iobyte back to CON=TTY and use TTY.
   178 F323 3A 03 00	        lda     iobyte
   179 F326 E6 FC	        ani     0FCh
   180 F328 32 03 00	        sta     iobyte
   181 F32B C3 BA F3	        jmp     ttyrdy
   182
   183 				;; === === === === === === === === === === === ===
   184 				;; get next character from con: into a and clear its parity bit.
   185 				;; use i/o byte to determine which device is the console.
   186 				;; if there is no data available, wait for some.
   187 				;; === === === === === === === === === === === ===
   188 			conin:
   189 F32E 3A 03 00	        lda     iobyte
   190 F331 E6 03	        ani     03h
   191 F333 CA CA F3	        jz      ttyget
   192 F336 FE 01	        cpi     1
   193 F338 CA F1 F3	        jz      crtget
   194 F33B FE 02	        cpi     2
   195 F33D CA 18 F4	        jz      pptget
   196 				;; no support for user defined consoles (yet?)
   197 				;; switch iobyte back to pure TTY and use TTY
   198 F340 AF		        xra     a
   199 F341 32 03 00	        sta     iobyte
   200 F344 C3 CA F3	        jmp     ttyget
   201
   202 				;; === === === === === === === === === === === ===
   203 				;; put the character in (C) to CON:
   204 				;; use i/o byte to determine which device is the console.
   205 			        ;; switch i/o byte to "pure TTY" if an invalid device is selected
   206 				;; if the device can not accept data, wait until it can.
   207 				;; modifies the content of register a.
   208 				;; === === === === === === === === === === === ===
   209 			conout:
   210 F347 3A 03 00	        lda     iobyte
   211 F34A E6 03	        ani     03h
   212 F34C CA D6 F3	        jz      ttyput
   213 F34F FE 01	        cpi     1
   214 F351 CA FD F3	        jz      crtput
   215 F354 FE 02	        cpi     2
   216 F356 CA 24 F4	        jz      pptput
   217 				;; no support for user defined consoles (yet?)
   218 				;; switch iobyte back to pure TTY and use tty
   219 F359 AF		        xra     a
   220 F35A 32 03 00	        sta     iobyte
   221 F35D C3 D6 F3	        jmp     ttyput
   222
   223 				;; === === === === === === === === === === === ===
   224 				;; put the the character in c to lst: 
   225 				;; use i/o byte to determine which device is the listing.
   226 			        ;; switch i/o byte to "pure TTY" if an invalid device is selected
   227 				;; if the device can not accept data, wait until it can.
   228 				;; modifies the content of register a.
   229 				;; === === === === === === === === === === === ===
   230
   231 			list:
   232 F360 3A 03 00	        lda     iobyte
   233 F363 E6 C0	        ani     0C0h
   234 F365 CA D6 F3	        jz      ttyput
   235 F368 FE 40	        cpi     040h
   236 F36A CA FD F3	        jz      crtput
   237 F36D FE 80	        cpi     080h
   238 F36F CA 37 F4	        jz      lptput
   239 				;; no support for user defined consoles (yet?)
   240 				;; switch iobyte back to pure TTY and use tty
   241 F372 AF		        xra     a
   242 F373 32 03 00	        sta     iobyte
   243 F376 C3 D6 F3	        jmp     ttyput
   244
   245 				;; === === === === === === === === === === === ===
   246 				;; return ff if lst: can accept a byte or 00 if not.
   247 				;; use i/o byte to determine which device is the listing.
   248 			        ;; switch i/o byte to "pure TTY" if an invalid device is selected
   249 				;; === === === === === === === === === === === ===
   250
   251 			listst:
   252 F379 3A 03 00	        lda     iobyte
   253 F37C E6 C0	        ani     0C0h
   254 F37E CA C2 F3	        jz      ttypok
   255 F381 FE 40	        cpi     040h
   256 F383 CA E9 F3	        jz      crtpok
   257 F386 FE 80	        cpi     080h
   258 F388 CA 2F F4	        jz      lptpok
   259 				;; no support for user defined listing devices (yet?)
   260 				;; switch iobyte back to pure TTY and use tty
   261 F38B AF		        xra     a
   262 F38C 32 03 00	        sta     iobyte
   263 F38F C3 C2 F3	        jmp     ttypok
   264
   265 				;; === === === === === === === === === === === ===
   266 				;; put the the character in c to pun: 
   267 				;; use i/o byte to determine which device is the listing.
   268 			        ;; switch i/o byte to "pure TTY" if an invalid device is selected
   269 				;; if the device can not accept data, wait until it can.
   270 				;; modifies the content of register a.
   271 				;; === === === === === === === === === === === ===
   272
   273 			punch:
   274 F392 3A 03 00	        lda     iobyte
   275 F395 E6 30	        ani     030h
   276 F397 CA D6 F3	        jz      ttyput
   277 F39A FE 10	        cpi     010h
   278 F39C CA 24 F4	        jz      pptput
   279 				;; no support for user defined punches (yet?)
   280 				;; switch iobyte back to pure TTY and use TTY
   281 F39F AF		        xra     a
   282 F3A0 32 03 00	        sta     iobyte
   283 F3A3 C3 D6 F3	        jmp     ttyput
   284
   285 				;; === === === === === === === === === === === ===
   286 				;; get next character from rdr: into a and clear its parity bit.
   287 				;; use i/o byte to determine which device is the listing.
   288 			        ;; switch i/o byte to "pure TTY" if an invalid device is selected
   289 				;; if there is no data available, wait for some.
   290 				;; no i/o byte support yet
   291 				;; === === === === === === === === === === === ===
   292
   293 			reader:
   294 F3A6 3A 03 00	        lda     iobyte
   295 F3A9 E6 0C	        ani     00Ch
   296 F3AB CA CA F3	        jz      ttyget
   297 F3AE FE 04	        cpi     004h
   298 F3B0 CA 18 F4	        jz      pptget
   299 				;; no support for user defined readers (yet?)
   300 				;; switch iobyte back to pure TTY and use TTY
   301 F3B3 AF		        xra     a
   302 F3B4 32 03 00	        sta     iobyte
   303 F3B7 C3 CA F3	        jmp     ttyget
   304
   305 			;;; === === === === === === === === === === === === === === === ===
   306 			;;; Interaction with CDEV devices
   307 			;;; === === === === === === === === === === === === === === === ===
   308
   309      00 00	ttyd	equ     0               ;read/write data from/to printing console
   310      00 01	ttyc	equ     1               ;printing console status/control port
   311
   312 				;; === === === === === === === === === === === ===
   313 				;; return ff if a byte is available on tty: or 00 if not.
   314 				;; === === === === === === === === === === === ===
   315 			ttyrdy:
   316 F3BA DB 01	        in      ttyc
   317 F3BC E6 02	        ani     02h
   318 F3BE C8		        rz
   319 F3BF 3E FF	        mvi     a,0ffh
   320 F3C1 C9		        ret
   321
   322 				;; === === === === === === === === === === === ===
   323 				;; return ff if tty: ready to accept data, or 00 if not.
   324 				;; === === === === === === === === === === === ===
   325 			ttypok:
   326 F3C2 DB 01	        in      ttyc
   327 F3C4 E6 02	        ani     02h
   328 F3C6 C8		        rz
   329 F3C7 3E FF	        mvi     a,0ffh
   330 F3C9 C9		        ret
   331
   332 				;; === === === === === === === === === === === ===
   333 			        ;; get next character from tty: into a and clear its parity bit.
   334 			        ;; if there is no data available, wait for some.
   335 				;; === === === === === === === === === === === ===
   336 			ttyget:
   337 F3CA DB 01	        in      ttyc
   338 F3CC E6 01	        ani     01h
   339 F3CE CA CA F3	        jz      ttyget
   340 F3D1 DB 00	        in      ttyd
   341 F3D3 E6 7F	        ani     7fh
   342 F3D5 C9		        ret
   343
   344 				;; === === === === === === === === === === === ===
   345 				;; put the the character in c to tty: 
   346 				;; if the device can not accept data, wait until it can.
   347 				;; modifies the content of register a.
   348 				;; === === === === === === === === === === === ===
   349 			ttyput:
   350 F3D6 DB 01	        in      ttyc
   351 F3D8 E6 01	        ani     01h
   352 F3DA CA D6 F3	        jz      ttyput
   353 F3DD 79		        mov     a,c
   354 F3DE D3 00	        out     ttyd
   355 F3E0 C9		        ret
   356
   357      00 02	crtd	equ     2               ;read/write data from/to video console
   358      00 03	crtc	equ     3               ;video console status/control port
   359
   360 				;; === === === === === === === === === === === ===
   361 				;; return ff if a byte is available on crt: or 00 if not.
   362 				;; === === === === === === === === === === === ===
   363 			crtrdy:
   364 F3E1 DB 03	        in      crtc
   365 F3E3 E6 02	        ani     02h
   366 F3E5 C8		        rz
   367 F3E6 3E FF	        mvi     a,0ffh
   368 F3E8 C9		        ret
   369
   370 				;; === === === === === === === === === === === ===
   371 				;; return ff if crt: ready to accept data, or 00 if not.
   372 				;; === === === === === === === === === === === ===
   373 			crtpok:
   374 F3E9 DB 03	        in      crtc
   375 F3EB E6 02	        ani     02h
   376 F3ED C8		        rz
   377 F3EE 3E FF	        mvi     a,0ffh
   378 F3F0 C9		        ret
   379
   380 				;; === === === === === === === === === === === ===
   381 			        ;; get next character from crt: into a and clear its parity bit.
   382 			        ;; if there is no data available, wait for some.
   383 				;; === === === === === === === === === === === ===
   384 			crtget:
   385 F3F1 DB 03	        in      crtc
   386 F3F3 E6 01	        ani     01h
   387 F3F5 CA F1 F3	        jz      crtget
   388 F3F8 DB 02	        in      crtd
   389 F3FA E6 7F	        ani     7fh
   390 F3FC C9		        ret
   391
   392 				;; === === === === === === === === === === === ===
   393 				;; put the the character in c to crt: 
   394 				;; if the device can not accept data, wait until it can.
   395 				;; modifies the content of register a.
   396 				;; === === === === === === === === === === === ===
   397 			crtput:
   398 F3FD DB 03	        in      crtc
   399 F3FF E6 01	        ani     01h
   400 F401 CA FD F3	        jz      crtput
   401 F404 79		        mov     a,c
   402 F405 D3 02	        out     crtd
   403 F407 C9		        ret
   404
   405      00 04	pptd	equ     4               ;read/write data from/to paper tape
   406      00 05	pptc	equ     5               ;paper tape status/control port
   407
   408 				;; === === === === === === === === === === === ===
   409 				;; return ff if a byte is available on ppt: or 00 if not.
   410 				;; === === === === === === === === === === === ===
   411 			pptrdy:
   412 F408 DB 05	        in      pptc
   413 F40A E6 02	        ani     02h
   414 F40C C8		        rz
   415 F40D 3E FF	        mvi     a,0ffh
   416 F40F C9		        ret
   417
   418 				;; === === === === === === === === === === === ===
   419 				;; return ff if ppt: ready to accept data, or 00 if not.
   420 				;; === === === === === === === === === === === ===
   421 			pptpok:
   422 F410 DB 05	        in      pptc
   423 F412 E6 02	        ani     02h
   424 F414 C8		        rz
   425 F415 3E FF	        mvi     a,0ffh
   426 F417 C9		        ret
   427
   428 				;; === === === === === === === === === === === ===
   429 			        ;; get next character from ppt: into a and clear its parity bit.
   430 			        ;; if there is no data available, wait for some.
   431 				;; === === === === === === === === === === === ===
   432 			pptget:
   433 F418 DB 05	        in      pptc
   434 F41A E6 01	        ani     01h
   435 F41C CA 18 F4	        jz      pptget
   436 F41F DB 04	        in      pptd
   437 F421 E6 7F	        ani     7fh
   438 F423 C9		        ret
   439
   440 				;; === === === === === === === === === === === ===
   441 				;; put the the character in c to ppt: 
   442 				;; if the device can not accept data, wait until it can.
   443 				;; modifies the content of register a.
   444 				;; === === === === === === === === === === === ===
   445 			pptput:
   446 F424 DB 05	        in      pptc
   447 F426 E6 01	        ani     01h
   448 F428 CA 24 F4	        jz      pptput
   449 F42B 79		        mov     a,c
   450 F42C D3 04	        out     pptd
   451 F42E C9		        ret
   452
   453      00 06	lptd	equ     6               ;write data to line printer
   454      00 07	lptc	equ     7               ;line printer status/control port
   455
   456 				;; === === === === === === === === === === === ===
   457 				;; return ff if lpt: ready to accept data, or 00 if not.
   458 				;; === === === === === === === === === === === ===
   459 			lptpok:
   460 F42F DB 07	        in      lptc
   461 F431 E6 02	        ani     02h
   462 F433 C8		        rz
   463 F434 3E FF	        mvi     a,0ffh
   464 F436 C9		        ret
   465
   466 				;; === === === === === === === === === === === ===
   467 				;; put the the character in c to lpt: 
   468 				;; if the device can not accept data, wait until it can.
   469 				;; modifies the content of register a.
   470 				;; === === === === === === === === === === === ===
   471 			lptput:
   472 F437 DB 07	        in      lptc
   473 F439 E6 01	        ani     01h
   474 F43B CA 37 F4	        jz      lptput
   475 F43E 79		        mov     a,c
   476 F43F D3 06	        out     lptd
   477 F441 C9		        ret
   478
   479
   480 			;;; === === === === === === === === === === === === === === === ===
   481 			;;;	i/o drivers for the disk follow
   482 			;;;	for now, we will simply store the parameters away for use
   483 			;;;	in the read and write subroutines
   484 			;;; === === === === === === === === === === === === === === === ===
   485
   486 			;;; === === === === === === === === === === === === === === === ===
   487 			;;; disk controller i/o ports
   488 			;;; === === === === === === === === === === === === === === === ===
   489
   490      00 0A	bdres	equ	10              ;reset controller (drv 0, trk 0, sec 1)
   491      00 0B	bddrv	equ	11              ;select drive
   492      00 0C	bdtrk	equ	12              ;select track
   493      00 0D	bdsec	equ	13              ;select sector
   494      00 0E	bddat	equ	14              ;read/write next byte
   495
   496 			;;; === === === === === === === === === === === === === === === ===
   497 			;;; return the disk head of the currently selected disk (initially
   498 			;;; disk a) to the track 00 position. if your controller allows
   499 			;;; access to the track 0 flag from the device, step the head until
   500 			;;; the track 0 flag is detected. if your controller does not
   501 			;;; support this feature, you can translate the home call into a
   502 			;;; call on settrk with a parameter of 0.
   503 			;;; === === === === === === === === === === === === === === === ===
   504
   505 			home:
   506 F442 0E 00	        mvi     c,0
   507 F444 CD 5F F4	        call    settrk
   508 F447 C9		        ret
   509
   510
   511 			;;; === === === === === === === === === === === === === === === ===
   512 			;;; select the disk drive given by register c for further opera-
   513 			;;; tions, where register c contains 0 for drive a, 1 for drive b,
   514 			;;; 2 for drive c, and 3 for drive d. (the standard cp/m
   515 			;;; distribution supports a maximum of four drives). if
   516 			;;; your system has less than 4 drives, you may wish to give an
   517 			;;; error message at the console, and terminate execution. it is
   518 			;;; advisable to postpone the actual disk operation until
   519 			;;; an i/o function (seek, read or write) is actually performed,
   520 			;;; since disk selects often occur without ultimately performing
   521 			;;; any disk i/o, and many controllers will unload the head of the
   522 			;;; current disk before selecting the new drive. this would
   523 			;;; cause an excessive amount of noise and disk wear.
   524 			;;;
   525 			;;; voidstar8080: this call resets the controller, in case a previous
   526 			;;; read or write operation did not complete properly. This is a "soft"
   527 			;;; reset; the disk array (real or simulated) state is not modified
   528 			;;; until we actually initiate a read or write.
   529 			;;;
   530 			;;; CP/M 2.2: locate and return the DPB for this drive in HL,
   531 			;;; or set HL to 0000h if the drive is not within our DPB table.
   532 			;;; HOWEVER NOTE: large disk numbers still get sent to BDEV controller.
   533 			;;; === === === === === === === === === === === === === === === ===
   534 			seldsk:
   535 F448 21 00 00		lxi	h, 0000h	;error return code
   536 F44B 79			mov	a, c
   537 F44C D3 0A	        out     bdres           ;reset bdev controller
   538 F44E D3 0B	        out     bddrv           ;select bdev drive number
   539
   540 F450 FE 04		cpi	ndisk		;check for disk number in table rane
   541 F452 D0			rnc			;return with HL=0000 if off end of table
   542 			;	disk number is in the proper range
   543
   544 			;	compute proper disk Parameter header address
   545 F453 6F			mov	l, a		;l=disk number 0, 1, 2, 3
   546 F454 26 00		mvi	h, 0		;high order zero
   547 F456 29			dad	h		;*2
   548 F457 29			dad	h		;*4
   549 F458 29			dad	h		;*8
   550 F459 29			dad	h		;*16 (size of each header)
   551 F45A 11 33 F2		lxi	d, dpbase
   552 F45D 19			dad	d		;hl=.dpbase (diskno*16)
   553 F45E C9			ret
   554
   555 			;;; === === === === === === === === === === === === === === === ===
   556 			;;; register c contains the track number for subsequent disk
   557 			;;; accesses on the currently selected drive. you can choose to
   558 			;;; seek the selected track at this time, or delay the seek until
   559 			;;; the next read or write actually occurs. register c can take
   560 			;;; on values in the range 0-76 corresponding to valid track
   561 			;;; numbers.
   562 			;;;
   563 			;;; voidstar8080: pass the track number along to the controller.
   564 			;;; === === === === === === === === === === === === === === === ===
   565
   566 			settrk:
   567 F45F 79			mov	a, c
   568 F460 D3 0C	        out     bdtrk
   569 F462 C9			ret
   570
   571 			;;; === === === === === === === === === === === === === === === ===
   572 			;;; register c contains the sector number (1 through 26) for sub-
   573 			;;; sequent disk accesses on the currently selected drive. you
   574 			;;; can choose to send this information to the controller at this
   575 			;;; point, or instead delay sector selectino until a read
   576 			;;; or write opration occurs.
   577 			;;; === === === === === === === === === === === === === === === ===
   578
   579 			setsec:
   580 F463 79		        mov     a,c
   581 F464 D3 0D	        out     bdsec
   582 F466 C9		        ret
   583
   584 			;;; === === === === === === === === === === === === === === === ===
   585 			;;; translate the sector given by bc using the
   586 			;;; translate table given by de
   587 			;;; === === === === === === === === === === === === === === === ===
   588
   589 			sectran:
   590 F467 EB			xchg			;hl=.trans
   591 F468 09			dad	b		;hl=.trans (sector)
   592 F469 6E			mov	l, m		;l=trans (sector)
   593 F46A 26 00		mvi	h, 0		;hl=trans (sector)
   594 F46C C9			ret			;with value in hl
   595
   596 			;;; === === === === === === === === === === === === === === === ===
   597 			;;; registers b and c (high-order 8 bits in b, low-order 8 bits
   598 			;;; in c) contain the dma (direct memory access) address for sub-
   599 			;;; sequent read or write operations. for example, if b = 00h
   600 			;;; and c = 80h when setdma is called, then all subsequent read
   601 			;;; operations read their data into 80h through 0ffh, and all
   602 			;;; subsequent write operations get their data from 80h through
   603 			;;; 0ffh, until the next call to setdma occurs. the initial
   604 			;;; dma address is assumed to be 80h. note that the controller
   605 			;;; need not actually support direct memory access. if, for
   606 			;;; example, all data is received and sent through i/o ports, the
   607 			;;; cbios which you construct will use he 128-byte area starting
   608 			;;; at the selected dma address for the memory buffer during the
   609 			;;; following read or write operations.
   610 			;;; === === === === === === === === === === === === === === === ===
   611
   612 			setdma:
   613 F46D 69			mov	l, c		;low order address
   614 F46E 60			mov	h, b		;high order address
   615 F46F 22 00 F5		shld	dmaad		;save the address
   616 F472 C9			ret
   617
   618 			;;; === === === === === === === === === === === === === === === ===
   619 			;;; assuming the drive has been selected, the track has been set,
   620 			;;; the sector has been set, and the dma address has been speci-
   621 			;;; fied, the read subroutine attempts to read one sector based
   622 			;;; upon these parameters, and returns the following error codes
   623 			;;; in register a:
   624 			;;;
   625 			;;;            0      no errors occurred
   626 			;;;            1      non-recoverable error condition occurred
   627 			;;;
   628 			;;; currently, cp/m responds only to a zero or non-zero value as
   629 			;;; the return code. that is, if the value in register a is 0
   630 			;;; then cp/m assumes that the disk operation completed properly.
   631 			;;; if an error occurs, however, the cbios should attempt at
   632 			;;; least 10 re-tries to see if the error is recoverable. when an
   633 			;;; error is reported the bdos will print the message "bdos err
   634 			;;; on x: bad sector." the operator then has the option of
   635 			;;; typing <cr> to ignore the error, or control-c to abort.
   636 			;;; === === === === === === === === === === === === === === === ===
   637 			read:   
   638 F473 2A 00 F5	        lhld    dmaad
   639 F476 0E 80	        mvi     c,128
   640 			readl:
   641 F478 DB 0E	        in      bddat
   642 F47A 77		        mov     m,a
   643 F47B 23		        inx     hl
   644 F47C 0D		        dcr     c
   645 F47D C2 78 F4	        jnz     readl
   646 F480 AF		        xra     a
   647 F481 C9		        ret
   648
   649 			;;; === === === === === === === === === === === === === === === ===
   650 			;;; write the data from the currently selected dma address to the
   651 			;;; currently selected drive, track, and sector. the data should
   652 			;;; be marked as "non deleted data" to maintain compatibility
   653 			;;; with other cp/m systems. the error codes given in the read
   654 			;;; command are returned in register a, with error recovery at-
   655 			;;; tempts as described above.
   656 			;;; === === === === === === === === === === === === === === === ===
   657 			write:  
   658 F482 2A 00 F5	        lhld    dmaad
   659 F485 0E 80	        mvi     c,128
   660 			writel:
   661 F487 7E		        mov     a,m
   662 F488 D3 0E	        out     bddat
   663 F48A 23		        inx     hl
   664 F48B 0D		        dcr     c
   665 F48C C2 87 F4	        jnz     writel
   666 F48F AF		        xra     a
   667 F490 C9		        ret
   668
   669      F4 91	endbios	equ	$
   670
   671 			;;; === === === === === === === === === === === === === === === ===
   672 			;	the remainder of the cbios is reserved uninitialized
   673 			;	data area, and does not need to be a part of the
   674 			;	system memory image (the space must be available,
   675 			;	however, between the BIOS and the end of memory).
   676 			;
   677      F5 00	        org	bioslim
   678 			bss:    	 	;beginning of data area
   679
   680 F500		dmaad:	ds	2	;direct memory address
   681
   682 F502		dirbf:	ds	128	;scratch directory area
   683 F582		all00:	ds	31	;allocation vector 0
   684 F5A1		all01:	ds	31	;allocation vector 1
   685 F5C0		all02:	ds	31	;allocation vector 2
   686 F5DF		all03:	ds	31	;allocation vector 3
   687 F5FE		chk00:	ds	16	;check vector 0
   688 F60E		chk01:	ds	16	;check vector 1
   689 F61E		chk02:	ds	16	;check vector 2
   690 F62E		chk03:	ds	16	;check vector 3
   691 			endbss:			;end of data area
   692 			        
   693      02 91	bioslen	equ     endbios-bios        
   694      00 6F	biosavl	equ	bioslim-endbios	;can add this much to the BIOS segment
   695
   696      01 3E	bsslen	equ	endbss-bss;	;size of bssa area
   697      01 42	bssavl	equ	0280H-bsslen	;can add this much to the BSS segment
   698
   699     			end


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names		Types	Values
-----		-----	------
msize		EQU	0003Eh
bias		EQU	0A800h
ccp		EQU	0DC00h
bdos		EQU	0E406h
bios		EQU	0F200h
bioslim		EQU	0F500h
iobyte		EQU	00003h
cdisk		EQU	00004h
nsects		EQU	0002Ch
ndisk		EQU	00004h
ttyd		EQU	00000h
ttyc		EQU	00001h
crtd		EQU	00002h
crtc		EQU	00003h
pptd		EQU	00004h
pptc		EQU	00005h
lptd		EQU	00006h
lptc		EQU	00007h
bdres		EQU	0000Ah
bddrv		EQU	0000Bh
bdtrk		EQU	0000Ch
bdsec		EQU	0000Dh
bddat		EQU	0000Eh
endbios		EQU	0F491h
bioslen		EQU	00291h
biosavl		EQU	0006Fh
bsslen		EQU	0013Eh
bssavl		EQU	00142h
wboote		Label	0F203h
dpbase		Label	0F233h
trans		Label	0F273h
dpblk		Label	0F28Dh
boot		Label	0F29Ch
wboot		Label	0F2A6h
load1		Label	0F2BAh
gocpm		Label	0F2EFh
const		Label	0F311h
conin		Label	0F32Eh
conout		Label	0F347h
list		Label	0F360h
listst		Label	0F379h
punch		Label	0F392h
reader		Label	0F3A6h
ttyrdy		Label	0F3BAh
ttypok		Label	0F3C2h
ttyget		Label	0F3CAh
ttyput		Label	0F3D6h
crtrdy		Label	0F3E1h
crtpok		Label	0F3E9h
crtget		Label	0F3F1h
crtput		Label	0F3FDh
pptrdy		Label	0F408h
pptpok		Label	0F410h
pptget		Label	0F418h
pptput		Label	0F424h
lptpok		Label	0F42Fh
lptput		Label	0F437h
home		Label	0F442h
seldsk		Label	0F448h
settrk		Label	0F45Fh
setsec		Label	0F463h
sectran		Label	0F467h
setdma		Label	0F46Dh
read		Label	0F473h
readl		Label	0F478h
write		Label	0F482h
writel		Label	0F487h
bss		Label	0F500h
dmaad		Label	0F500h
dirbf		Label	0F502h
all00		Label	0F582h
all01		Label	0F5A1h
all02		Label	0F5C0h
all03		Label	0F5DFh
chk00		Label	0F5FEh
chk01		Label	0F60Eh
chk02		Label	0F61Eh
chk03		Label	0F62Eh
endbss		Label	0F63Eh

Statistics
----------
"Name"	= 0
"EQU"	= 28
"SET"	= 0
Labels	= 51


