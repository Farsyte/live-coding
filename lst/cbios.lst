     1     			TITLE   'SKELETAL CBIOS FOR FIRST LEVEL OF CP/M ALTERATION'
     2 			;
     3 			;	NOTE: MSIZE DETERMINES WHERE THIS BIOS IS LOCATED.
     4      00 3E	MSIZE	EQU	62		;CP/M VERSION MEMORY SIZE IN KILOBYTES
     5      F6 00	PATCH	EQU	(MSIZE*1024)-(2*256)  ;START OF THE CBIOS PATCH
     6 			;
     7      F6 00		ORG	PATCH		;ORIGIN OF THIS PROGRAM
     8 			;
     9      B8 00	CBASE	EQU	(MSIZE-16)*1024 ;BIAS FOR SYSTEMS LARGER THAN 16K
    10      E1 00	CPMB	EQU	CBASE+2900H	;BASE OF CP/M (= BASE OF CCP)
    11      E9 06	BDOS	EQU	CBASE+3106H	;BASE OF RESIDENT PORTION OF CP/M
    12      15 00	CPML	EQU	$-CPMB		;LENGTH OF THE CP/M SYSTEM IN BYTES
    13      00 2A	NSECTS	EQU	CPML/128	;NUMBER OF SECTORS TO LOAD ON WARM START
    14 			;
    15 			;	PAGE ZERO STUFF:
    16 			;
    17      00 03	IOBYTE	EQU	0003H
    18      00 04	CDISK	EQU	0004H
    19 			;
    20      00 40	SCRAT	EQU	40H	;USE THE AREA RESERVED FOR US AT 40H TO HOLD:
    21      00 40	TRACK	EQU	SCRAT+0		;LAST SELECTED TRACK
    22      00 41	SECTOR	EQU	SCRAT+1		;LAST SELECTED SECTOR
    23      00 42	DMAAD	EQU	SCRAT+2		;LAST SELECTED DMA ADDRESS
    24      00 44	DISKNO	EQU	SCRAT+4		;LAST SELECTED DISK NUMBER
    25 			;
    26 			;	JUMP VECTOR FOR INDIVIDUAL SUBROUTINES
    27 			;
    28 F600 C3 2D F6		JMP	BOOT	;COLD START
    29 			WBOOTE:
    30 F603 C3 30 F6		JMP	WBOOT	;WARM START
    31
    32 F606 C3 9B F6		JMP	CONST	;CONSOLE STATUS
    33 F609 C3 9F F6		JMP	CONIN	;CONSOLE CHARACTER IN
    34 F60C C3 A2 F6		JMP	CONOUT	;CONSOLE CHARACTER OUT
    35 F60F C3 A4 F6		JMP	LIST	;LIST CHARACTER OUT
    36 F612 C3 A6 F6		JMP	PUNCH	;PUNCH CHARACTER OUT
    37 F615 C3 A8 F6		JMP	READER	;READER CHARACTER OUT
    38
    39 F618 C3 AA F6		JMP	HOME	;MOVE HEAD TO HOME POSITION
    40 F61B C3 B0 F6		JMP	SELDSK	;SELECT DISK
    41 F61E C3 B5 F6		JMP	SETTRK	;SET TRACK NUMBER
    42 F621 C3 BA F6		JMP	SETSEC	;SET SECTOR NUMBER
    43 F624 C3 BF F6		JMP	SETDMA	;SET DMA ADDRESS
    44 F627 C3 C5 F6		JMP	READ	;READ DISK
    45 F62A C3 C7 F6		JMP	WRITE	;WRITE DISK
    46
    47 			;; added in cp/m 2.0:
    48 			;;	JMP	LISTST	;RETURN LIST STATUS
    49 			;;	JMP	SECTRAN	;SECTOR TRANSLATE
    50
    51     		        PAGE
    52
    53 			;;; INDIVIDUAL SUBROUTINES TO PERFORM EACH FUNCTION
    54
    55
    56 			;;; The BOOT entry point gets control from the cold start loader
    57 			;;; and is responsible for basic system initialization, includ-
    58 			;;; ing sending a sign-on message (which can be omitted in the
    59 			;;; first version). If the IOBYTE function is implemented, it
    60 			;;; must be set at this point. The various system parameters
    61 			;;; which are set by the WBOOT entry point must be initialized,
    62 			;;; and control is transferred to the CCP at 2900H+b for further
    63 			;;; processing. Note that reg C must be set to zero to select
    64 			;;; drive A.
    65
    66 			BOOT:
    67 F62D C3 79 F6	        JMP     GOCPM           ;INITIALIZE AND GO TO CP/M
    68
    69 			;;; The WBOOT entry point gets control when a warm start occurs.
    70 			;;; A warm start is performed whenever a user program branches to
    71 			;;; location 0000H, or when the CPU is reset from the front panel.
    72 			;;; The CP/M system must be loaded from the first two tracks of
    73 			;;; drive A up to, but not including, the BIOS (or CBIOS, if you
    74 			;;; have completed your patch). System parameters must be ini-
    75 			;;; tialized as shown below:
    76 			;;;
    77 			;;;          location 0,1,2    Set to JMP WBOOT for warm starts
    78 			;;;                            (0000H: JMP 3E03H+b)
    79 			;;;          location 3        Set initial value of IOBYTE, if
    80 			;;;                            implemented in your CBIOS.
    81 			;;;          location 5,6,7    Set to JMP BDOS, which is the
    82 			;;;                            primary entry point to CP/M for
    83 			;;;                            transient programs
    84 			;;;                            (0005H: JMP 3106H+b)
    85 			;;;
    86 			;;; Upon completion of the initialization, the WBOOT program
    87 			;;; must branch to the CCP at 2900H+b to (re)start the system.
    88 			;;; Upon entry to the CCP, register C is set to the drive to
    89 			;;; select after system initialization.
    90
    91 			WBOOT:  ;SIMPLEST CASE IS TO READ THEDISK UNTIL ALL SECTORS LOADED
    92 F630 31 80 00		LXI	SP, 80H		;USE SPACE BELOW BUFFER FOR STACK
    93 F633 0E 00		MVI	C, 0		;SELECT DISK 0
    94 F635 CD B0 F6		CALL	SELDSK
    95 F638 CD AA F6		CALL	HOME		;GO TO TRACK 00
    96 			;
    97 F63B 06 2A		MVI	B, NSECTS	;B COUNTS * OF SECTORS TO LOAD
    98 F63D 0E 00		MVI	C, 0		;C HAS THE CURRENT TRACK NUMBER
    99 F63F 16 02		MVI	D, 2		;D HAS THE NEXT SECTOR TO READ
   100 			;	NOTE THAT WE BEGIN BY READING TRACK 0, SECTOR 2 SINCE SECTOR 1
   101 			;	CONTAINS THE COLD START LOADER, WHICH IS SKIPPED IN A WARM START
   102 F641 21 00 E1		LXI	H, CPMB		;BASE OF CP/M (INITIAL LOAD POINT)
   103 			LOAD1:	;LOAD	ONE MORE SECTOR
   104 F644 C5			PUSH	B		;SAVE SECTOR COUNT, CURRENT TRACK
   105 F645 D5			PUSH	D		;SAVE NEXT SECTOR TO READ
   106 F646 E5			PUSH	H		;SAVE DMA ADDRESS
   107 F647 4A			MOV	C, D		;GET SECTOR ADDRESS TO REGISTER C
   108 F648 CD BA F6		CALL	SETSEC		;SET SECTOR ADDRESS FROM REGISTER C
   109 F64B C1			POP	B		;RECALL DMA ADDRESS TO B, C
   110 F64C C5			PUSH	B		;REPLACE ON STACK FOR LATER RECALL
   111 F64D CD BF F6		CALL	SETDMA		;SET DMA ADDRESS FROM B, C
   112 			;
   113 			;	DRIVE SET TO 0, TRACK SET, SECTOR SET, DMA ADDRESS SET
   114 F650 CD C5 F6		CALL	READ
   115 F653 FE 00		CPI	00H		;ANY ERRORS?
   116 F655 C2 30 F6		JNZ	WBOOT		;RETRY THE ENTIRE BOOT IF AN ERROR OCCURS
   117 			;
   118 			;	NO ERROR, MOVE TO NEXT SECTOR
   119 F658 E1			POP	H		;RECALL DMA ADDRESS
   120 F659 11 80 00		LXI	D, 128		;DMA=DMA+128
   121 F65C 19			DAD	D		;NEW DMA ADDRESS IS IN H, L
   122 F65D D1			POP	D		;RECALL SECTOR ADDRESS
   123 F65E C1			POP	B	        ;RECALL NUMBER OF SECTORS REMAINING, AND CURRENT TRK
   124 F65F 05			DCR	B		;SECTORS=SECTORS-1
   125 F660 CA 79 F6		JZ	GOCPM		;TRANSFER TO CP/M IF ALL HAVE BEEN LOADED
   126 			;
   127 			;	MORE SECTORS REMAIN TO LOAD, CHECK FOR TRACK CHANGE
   128 F663 14			INR	D
   129 F664 7A			MOV	A,D		;SECTOR=27?, IF SO, CHANGE TRACKS
   130 F665 FE 1B		CPI	27
   131 F667 DA 44 F6		JC	LOAD1		;CARRY GENERATED IF SECTOR<27
   132 			;
   133 			;	END OF CURRENT TRACK, GO TO NEXT TRACK
   134 F66A 16 01		MVI	D, 1		;BEGIN WITH FIRST SECTOR OF NEXT TRACK
   135 F66C 0C			INR	C		;TRACK=TRACK+1
   136 			;
   137 			;	SAVE REGISTER STATE, AND CHANGE TRACKS
   138 F66D C5			PUSH	B
   139 F66E D5			PUSH	D
   140 F66F E5			PUSH	H
   141 F670 CD B5 F6		CALL	SETTRK		;TRACK ADDRESS SET FROM REGISTER C
   142 F673 E1			POP	H
   143 F674 D1			POP	D
   144 F675 C1			POP	B
   145 F676 C3 44 F6		JMP	LOAD1		;FOR ANOTHER SECTOR
   146 			;
   147 			;	END OF	LOAD OPERATION, SET PARAMETERS AND GO TO CP/M
   148 			GOCPM:
   149 F679 3E C3		MVI	A, 0C3H		;C3 IS A JMP INSTRUCTION
   150 F67B 32 00 00		STA	0		;FOR JMP TO WBOOT
   151 F67E 21 03 F6		LXI	H, WBOOTE	;WBOOT ENTRY POINT
   152 F681 22 01 00		SHLD	1		;SET ADDRESS FIELD FOR JMP AT 0
   153 			;
   154 F684 32 05 00		STA	5		;FOR JMP TO BDOS
   155 F687 21 06 E9		LXI	H, BDOS		;BDOS ENTRY POINT
   156 F68A 22 06 00		SHLD	6		;ADDRESS FIELD OF JUMP AT 5 TO BDOS
   157 			;
   158 F68D 01 80 00		LXI	B, 80H		;DEFAULT DMA ADDRESS IS 80H
   159 F690 CD BF F6		CALL	SETDMA
   160 			;
   161 F693 FB			EI			;ENABLE THE INTERRUPT SYSTEM
   162 F694 3A 04 00		LDA	CDISK		;GET CURRENT DISK NUMBER
   163 F697 4F			MOV	C, A		;SEND TO THE CCP
   164 F698 C3 00 E1		JMP	CPMB		;GO TO CP/M FOR FURTHER PROCESSING
   165
   166 			;;; Sample the status of the currently assigned console device;
   167 			;;; return 0FFH in register A if a character is ready to read
   168 			;;; and 00H in register A if no console characters are ready.
   169
   170 			CONST:
   171 F69B 76			HLT                     ;content tbd
   172 F69C 3E 00	        MVI     A,00H
   173 F69E C9		        RET
   174
   175 			;;; Read the next console character into register A, and set the
   176 			;;; high-order (parity bit). If no console character is ready,
   177 			;;; wait until a character is typed before returning.
   178
   179 			CONIN:
   180 F69F 79		        MOV     A,C
   181 F6A0 76			HLT                     ;content tbd
   182 F6A1 C9		        RET
   183
   184 			;;; Send the character from register C to the console output de-
   185 			;;; veice. The character is in ASCII, with high-order (parity) bit
   186 			;;; set to zero. You may want to include a time-out on a line
   187 			;;; feed or carriage return, if your console device requires some
   188 			;;; time interval at the end of the line (such as a TI Silent 700
   189 			;;; terminal). You can, if you wish, filter out control char-
   190 			;;; acters which cause your console device to react in a strange
   191 			;;; way (a control-z causes the Lear Siegler terminal to clear
   192 			;;; the screen, for example).
   193
   194 F6A2 76		CONOUT: HLT                     ;content tbd
   195 F6A3 C9		        RET
   196
   197 			;;; Send the character from register C to the currently assigned
   198 			;;; listing device. The character is in ASCII with zero parity.
   199
   200 			LIST:
   201 F6A4 76			HLT                     ;content tbd
   202 F6A5 C9		        RET
   203
   204 			;;; Send the character from register C to the currently assigned
   205 			;;; punch device. The character is in ASCII with zero parity.
   206
   207 			PUNCH:
   208 F6A6 76			HLT                     ;content tbd
   209 F6A7 C9		        RET
   210
   211 			;;; Read the next character from the currently assigned reader de-
   212 			;;; vice into register A with zero parity (high-order bit must be
   213 			;;; zero), an end of file condition is reported by return an
   214 			;;; ASCII control-z (1AH).
   215
   216 			READER:
   217 F6A8 76			HLT                     ;content tbd
   218 F6A9 C9		        RET
   219
   220     		        PAGE
   221
   222 			;;; Return the disk head of the currently selected disk (initially
   223 			;;; disk A) to the track 00 position. If your controller allows
   224 			;;; access to the track 0 flag from the device, step the head until
   225 			;;; the track 0 flag is detected. If your controller does not
   226 			;;; support this feature, you can translate the HOME call into a
   227 			;;; call on SETTRK with a parameter of 0.
   228
   229 			HOME:
   230 F6AA 0E 00	        MVI     C,0
   231 F6AC CD B5 F6	        CALL    SETTRK
   232 F6AF C9		        RET
   233
   234 			;;; Select the disk drive given by register C for further opera-
   235 			;;; tions, where register C contains 0 for drive A, 1 for drive B,
   236 			;;; 2 for drive C, and 3 for drive D. (The standard CP/M
   237 			;;; distribution supports a maximum of four drives). If
   238 			;;; your system has less than 4 drives, you may wish to give an
   239 			;;; error message at the console, and terminate execution. It is
   240 			;;; advisable to postpone the actual disk operation until
   241 			;;; an I/O function (seek, read or write) is actually performed,
   242 			;;; since disk selects often occur without ultimately performing
   243 			;;; any disk I/O, and many controllers will unload the head of the
   244 			;;; current disk before selecting the new drive. This would
   245 			;;; cause an excessive amount of noise and disk wear.
   246
   247 			SELDSK:
   248 F6B0 79		        MOV     A,C
   249 F6B1 32 44 00	        STA     DISKNO
   250 F6B4 C9		        RET
   251
   252 			;;; Register C contains the track number for subsequent disk
   253 			;;; accesses on the currently selected drive. You can choose to
   254 			;;; seek the selected track at this time, or delay the seek until
   255 			;;; the next read or write actually occurs. Register C can take
   256 			;;; on values in the range 0-76 corresponding to valid track
   257 			;;; numbers.
   258
   259 			SETTRK:
   260 F6B5 79		        MOV     A,C
   261 F6B6 32 40 00	        STA     TRACK
   262 F6B9 C9		        RET
   263
   264 			;;; Register C contains the sector number (1 through 26) for sub-
   265 			;;; sequent disk accesses on the currently selected drive. You
   266 			;;; can choose to send this information to the controller at this
   267 			;;; point, or instead delay sector selectino until a read
   268 			;;; or write opration occurs.
   269
   270 			SETSEC:
   271 F6BA 79		        MOV     A,C
   272 F6BB 32 41 00	        STA     SECTOR
   273 F6BE C9		        RET
   274
   275 			;;; Registers B and C (high-order 8 bits in B, low-order 8 bits
   276 			;;; in C) contain the DMA (Direct Memory Access) address for sub-
   277 			;;; sequent read or write operations. For example, if B = 00H
   278 			;;; and C = 80H when SETDMA is called, then all subsequent read
   279 			;;; operations read their data into 80H through 0FFH, and all
   280 			;;; subsequent write operations get their data from 80H through
   281 			;;; 0FFH, until the next call to SETDMA occurs. The initial
   282 			;;; DMA address is assumed to be 80H. Note that the controller
   283 			;;; need not actually support direct memory access. If, for
   284 			;;; example, all data is received and sent through I/O ports, the
   285 			;;; CBIOS which you construct will use he 128-byte area starting
   286 			;;; at the selected DMA address for the memory buffer during the
   287 			;;; following read or write operations.
   288
   289 			SETDMA:
   290 F6BF 69		        MOV     L,C
   291 F6C0 60		        MOV     H,B
   292 F6C1 22 42 00	        SHLD    DMAAD
   293 F6C4 C9		        RET
   294
   295 			;;; Assuming the drive has been selected, the track has been set,
   296 			;;; the sector has been set, and the DMA address has been speci-
   297 			;;; fied, the READ subroutine attempts to read one sector based
   298 			;;; upon these parameters, and returns the following error codes
   299 			;;; in register A:
   300 			;;;
   301 			;;;            0      no errors occurred
   302 			;;;            1      non-recoverable error conditino occurred
   303 			;;;
   304 			;;; Currently, CP/M responds only to a zero or non-zero value as
   305 			;;; the return code. That is, if the value in register A is 0
   306 			;;; then CP/M assumes that the disk operation completed properly.
   307 			;;; If an error occurs, however, the CBIOS should attempt at
   308 			;;; least 10 re-trie to see if the error is recoverable. When an
   309 			;;; error is reported the BDOS will print the message "BDOS ERR
   310 			;;; ON x: BAD SECTOR." The operator then has the option of
   311 			;;; typing <cr> to ignore the error, or control-C to abort.
   312
   313 			READ:
   314 F6C5 76			HLT                     ;content tbd
   315 F6C6 C9		        RET
   316
   317 			;;; Write the data from the currently selected DMA address to the
   318 			;;; currently selected drive, track, and sector. The data should
   319 			;;; be marked as "non deleted data" to maintain compatibility
   320 			;;; with other CP/M systems. The error codes given in the READ
   321 			;;; command are returned in register A, with error recovery at-
   322 			;;; tempts as described above.
   323
   324 			WRITE:
   325 F6C7 76			HLT                     ;content tbd
   326 F6C8 C9		        RET
   327
   328      01 37	LEFT    EQU     (MSIZE*1024)-$


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names		Types	Values
-----		-----	------
MSIZE		EQU	0003Eh
PATCH		EQU	0F600h
CBASE		EQU	0B800h
CPMB		EQU	0E100h
BDOS		EQU	0E906h
CPML		EQU	01500h
NSECTS		EQU	0002Ah
IOBYTE		EQU	00003h
CDISK		EQU	00004h
SCRAT		EQU	00040h
TRACK		EQU	00040h
SECTOR		EQU	00041h
DMAAD		EQU	00042h
DISKNO		EQU	00044h
LEFT		EQU	00137h
WBOOTE		Label	0F603h
BOOT		Label	0F62Dh
WBOOT		Label	0F630h
LOAD1		Label	0F644h
GOCPM		Label	0F679h
CONST		Label	0F69Bh
CONIN		Label	0F69Fh
CONOUT		Label	0F6A2h
LIST		Label	0F6A4h
PUNCH		Label	0F6A6h
READER		Label	0F6A8h
HOME		Label	0F6AAh
SELDSK		Label	0F6B0h
SETTRK		Label	0F6B5h
SETSEC		Label	0F6BAh
SETDMA		Label	0F6BFh
READ		Label	0F6C5h
WRITE		Label	0F6C7h

Statistics
----------
"Name"	= 0
"EQU"	= 15
"SET"	= 0
Labels	= 18


