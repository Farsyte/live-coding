     1 			        ;; 2023-09-30 librarian note:
     2 			        ;;   retrieved from http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.asm
     3 			        ;;   no adjustments needed for "asm8080"
     4
     5 			;	skeletal cbios for first level of CP/M 2.0 alteration
     6 			;
     7      00 14	msize	equ	20		;cp/m version memory size in kilobytes
     8 			;
     9 			;	"bias" is address offset from 3400h for memory systems
    10 			;	than 16k (referred to as"b" throughout the text)
    11 			;
    12      00 00	bias	equ	(msize-20)*1024
    13      34 00	ccp	equ	3400h+bias	;base of ccp
    14      3C 06	bdos	equ	ccp+806h	;base of bdos
    15      4A 00	bios	equ	ccp+1600h	;base of bios
    16      00 04	cdisk	equ	0004h		;current disk number 0=a,... l5=p
    17      00 03	iobyte	equ	0003h		;intel i/o byte
    18 			;
    19      4A 00		org	bios		;origin of this program
    20      00 2C	nsects	equ	($-ccp)/128	;warm start sector count
    21 			;
    22 			;	jump vector for individual subroutines
    23 			;
    24 4A00 C3 9C 4A		jmp	boot	;cold start
    25 4A03 C3 A6 4A	wboote:	jmp	wboot	;warm start
    26 4A06 C3 11 4B		jmp	const	;console status
    27 4A09 C3 24 4B		jmp	conin	;console character in
    28 4A0C C3 37 4B		jmp	conout	;console character out
    29 4A0F C3 49 4B		jmp	list	;list character out
    30 4A12 C3 4D 4B		jmp	punch	;punch character out
    31 4A15 C3 4F 4B		jmp	reader	;reader character out
    32 4A18 C3 54 4B		jmp	home	;move head to home position
    33 4A1B C3 5A 4B		jmp	seldsk	;select disk
    34 4A1E C3 7D 4B		jmp	settrk	;set track number
    35 4A21 C3 92 4B		jmp	setsec	;set sector number
    36 4A24 C3 AD 4B		jmp	setdma	;set dma address
    37 4A27 C3 C3 4B		jmp	read	;read disk
    38 4A2A C3 D6 4B		jmp	write	;write disk
    39 4A2D C3 4B 4B		jmp	listst	;return list status
    40 4A30 C3 A7 4B		jmp	sectran	;sector translate
    41 			;
    42 			;	fixed data tables for four-drive standard
    43 			;	ibm-compatible 8" disks
    44 			;
    45 			;	disk Parameter header for disk 00
    46 4A33		dpbase:	dw	trans, 0000h
            734A 0000 
    47 4A37			dw	0000h, 0000h
            0000 0000 
    48 4A3B			dw	dirbf, dpblk
            F04C 8D4A 
    49 4A3F			dw	chk00, all00
            EC4D 704D 
    50 			;	disk parameter header for disk 01
    51 4A43			dw	trans, 0000h
            734A 0000 
    52 4A47			dw	0000h, 0000h
            0000 0000 
    53 4A4B			dw	dirbf, dpblk
            F04C 8D4A 
    54 4A4F			dw	chk01, all01
            FC4D 8F4D 
    55 			;	disk parameter header for disk 02
    56 4A53			dw	trans, 0000h
            734A 0000 
    57 4A57			dw	0000h, 0000h
            0000 0000 
    58 4A5B			dw	dirbf, dpblk
            F04C 8D4A 
    59 4A5F			dw	chk02, all02
            0C4E AE4D 
    60 			;	disk parameter header for disk 03
    61 4A63			dw	trans, 0000h
            734A 0000 
    62 4A67			dw	0000h, 0000h
            0000 0000 
    63 4A6B			dw	dirbf, dpblk
            F04C 8D4A 
    64 4A6F			dw	chk03, all03
            1C4E CD4D 
    65 			;
    66 			;	sector translate vector
    67 4A73		trans:	db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
            01 07 0D 13 
            
    68 4A77			db	25,  5, 11, 17	;sectors  5,  6,  7,  6
            19 05 0B 11 
            
    69 4A7B			db	23,  3,  9, 15	;sectors  9, 10, 11, 12
            17 03 09 0F 
            
    70 4A7F			db	21,  2,  8, 14	;sectors 13, 14, 15, 16
            15 02 08 0E 
            
    71 4A83			db	20, 26,  6, 12	;sectors 17, 18, 19, 20
            14 1A 06 0C 
            
    72 4A87			db	18, 24,  4, 10	;sectors 21, 22, 23, 24
            12 18 04 0A 
            
    73 4A8B			db	16, 22		;sectors 25, 26
            10 16 
    74 			;
    75 			dpblk:	;disk parameter block, common to all disks
    76 4A8D			dw	26		;sectors per track
            1A00 
    77 4A8F			db	3		;block shift factor
            03 
    78 4A90			db	7		;block mask
            07 
    79 4A91			db	0		;null mask
            00 
    80 4A92			dw	242		;disk size-1
            F200 
    81 4A94			dw	63		;directory max
            3F00 
    82 4A96			db	192		;alloc 0
            C0 
    83 4A97			db	0		;alloc 1
            00 
    84 4A98			dw	16		;check size
            1000 
    85 4A9A			dw	2		;track offset
            0200 
    86 			;
    87 			;	end of fixed tables
    88 			;
    89 			;	individual subroutines to perform each function
    90 			boot:	;simplest case is to just perform parameter initialization
    91 4A9C AF			xra	a		;zero in the accum
    92 4A9D 32 03 00		sta	iobyte		;clear the iobyte
    93 4AA0 32 04 00		sta	cdisk		;select disk zero
    94 4AA3 C3 EF 4A		jmp	gocpm		;initialize and go to cp/m
    95 			;
    96 			wboot:	;simplest case is to read the disk until all sectors loaded
    97 4AA6 31 80 00		lxi	sp, 80h		;use space below buffer for stack
    98 4AA9 0E 00		mvi	c, 0		;select disk 0
    99 4AAB CD 5A 4B		call	seldsk
   100 4AAE CD 54 4B		call	home		;go to track 00
   101 			;
   102 4AB1 06 2C		mvi	b, nsects	;b counts * of sectors to load
   103 4AB3 0E 00		mvi	c, 0		;c has the current track number
   104 4AB5 16 02		mvi	d, 2		;d has the next sector to read
   105 			;	note that we begin by reading track 0, sector 2 since sector 1
   106 			;	contains the cold start loader, which is skipped in a warm start
   107 4AB7 21 00 34		lxi	h, ccp		;base of cp/m (initial load point)
   108 			load1:	;load	one more sector
   109 4ABA C5			push	b		;save sector count, current track
   110 4ABB D5			push	d		;save next sector to read
   111 4ABC E5			push	h		;save dma address
   112 4ABD 4A			mov	c, d		;get sector address to register C
   113 4ABE CD 92 4B		call	setsec		;set sector address from register C
   114 4AC1 C1			pop	b		;recall dma address to b, C
   115 4AC2 C5			push	b		;replace on stack for later recall
   116 4AC3 CD AD 4B		call	setdma		;set dma address from b, C
   117 			;
   118 			;	drive set to 0, track set, sector set, dma address set
   119 4AC6 CD C3 4B		call	read
   120 4AC9 FE 00		cpi	00h		;any errors?
   121 4ACB C2 A6 4A		jnz	wboot		;retry the entire boot if an error occurs
   122 			;
   123 			;	no error, move to next sector
   124 4ACE E1			pop	h		;recall dma address
   125 4ACF 11 80 00		lxi	d, 128		;dma=dma+128
   126 4AD2 19			dad	d		;new dma address is in h, l
   127 4AD3 D1			pop	d		;recall sector address
   128 4AD4 C1			pop	b	;recall number of sectors remaining, and current trk
   129 4AD5 05			dcr	b		;sectors=sectors-1
   130 4AD6 CA EF 4A		jz	gocpm		;transfer to cp/m if all have been loaded
   131 			;
   132 			;	more	sectors remain to load, check for track change
   133 4AD9 14			inr	d
   134 4ADA 7A			mov	a,d		;sector=27?, if so, change tracks
   135 4ADB FE 1B		cpi	27
   136 4ADD DA BA 4A		jc	load1		;carry generated if sector<27
   137 			;
   138 			;	end of	current track,	go to next track
   139 4AE0 16 01		mvi	d, 1		;begin with first sector of next track
   140 4AE2 0C			inr	c		;track=track+1
   141 			;
   142 			;	save	register state, and change tracks
   143 4AE3 C5			push	b
   144 4AE4 D5			push	d
   145 4AE5 E5			push	h
   146 4AE6 CD 7D 4B		call	settrk		;track address set from register c
   147 4AE9 E1			pop	h
   148 4AEA D1			pop	d
   149 4AEB C1			pop	b
   150 4AEC C3 BA 4A		jmp	load1		;for another sector
   151 			;
   152 			;	end of	load operation, set parameters and go to cp/m
   153 			gocpm:
   154 4AEF 3E C3		mvi	a, 0c3h		;c3 is a jmp instruction
   155 4AF1 32 00 00		sta	0		;for jmp to wboot
   156 4AF4 21 03 4A		lxi	h, wboote	;wboot entry point
   157 4AF7 22 01 00		shld	1		;set address field for jmp at 0
   158 			;
   159 4AFA 32 05 00		sta	5		;for jmp to bdos
   160 4AFD 21 06 3C		lxi	h, bdos		;bdos entry point
   161 4B00 22 06 00		shld	6		;address field of Jump at 5 to bdos
   162 			;
   163 4B03 01 80 00		lxi	b, 80h		;default dma address is 80h
   164 4B06 CD AD 4B		call	setdma
   165 			;
   166 4B09 FB			ei			;enable the interrupt system
   167 4B0A 3A 04 00		lda	cdisk		;get current disk number
   168 4B0D 4F			mov	c, a		;send to the ccp
   169 4B0E C3 00 34		jmp	ccp		;go to cp/m for further processing
   170 			;
   171 			;
   172 			;	simple i/o handlers (must be filled in by user)
   173 			;	in each case, the entry point is provided, with space reserved
   174 			;	to insert your own code
   175 			;
   176 			const:	;console status, return 0ffh if character ready, 00h if not
   177 4B11			ds     10h		;space for status subroutine
   178 4B21 3E 00		mvi    a, 00h
   179 4B23 C9			ret
   180 			;
   181 			conin:	;console character into register a
   182 4B24			ds	10h		;space for input routine
   183 4B34 E6 7F		ani	7fh		;strip parity bit
   184 4B36 C9			ret
   185 			;
   186 			conout:	;console character output from register c
   187 4B37 79			mov	a, c		;get to accumulator
   188 4B38			ds	10h		;space for output routine
   189 4B48 C9			ret
   190 			;
   191 			list:	;list character from register c
   192 4B49 79			mov	a, c	  	;character to register a
   193 4B4A C9			ret		  	;null subroutine
   194 			;
   195 			listst:	;return list status (0 if not ready, 1 if ready)
   196 4B4B AF			xra	a	 	;0 is always ok to return
   197 4B4C C9			ret
   198 			;
   199 			punch:	;punch	character from	register C
   200 4B4D 79			mov	a, c		;character to register a
   201 4B4E C9			ret			;null subroutine
   202 			;
   203 			;
   204 			reader:	;reader character into register a from reader device
   205 4B4F 3E 1A		mvi    a, 1ah		;enter end of file for now (replace later)
   206 4B51 E6 7F		ani    7fh		;remember to strip parity bit
   207 4B53 C9			ret
   208 			;
   209 			;
   210 			;	i/o drivers for the disk follow
   211 			;	for now, we will simply store the parameters away for use
   212 			;	in the read and write	subroutines
   213 			;
   214 			home:	;move to the track 00	position of current drive
   215 			;	translate this call into a settrk call with Parameter 00
   216 4B54 0E 00		mvi    c, 0		;select track 0
   217 4B56 CD 7D 4B		call   settrk
   218 4B59 C9			ret			;we will move to 00 on first read/write
   219 			;
   220 			seldsk:	;select disk given by register c
   221 4B5A 21 00 00		lxi	h, 0000h	;error return code
   222 4B5D 79			mov	a, c
   223 4B5E 32 EF 4C		sta	diskno
   224 4B61 FE 04		cpi	4		;must be between 0 and 3
   225 4B63 D0			rnc			;no carry if 4, 5,...
   226 			;	disk number is in the proper range
   227 4B64			ds	10		;space for disk select
   228 			;	compute proper disk Parameter header address
   229 4B6E 3A EF 4C		lda	diskno
   230 4B71 6F			mov	l, a		;l=disk number 0, 1, 2, 3
   231 4B72 26 00		mvi	h, 0		;high order zero
   232 4B74 29			dad	h		;*2
   233 4B75 29			dad	h		;*4
   234 4B76 29			dad	h		;*8
   235 4B77 29			dad	h		;*16 (size of each header)
   236 4B78 11 33 4A		lxi	d, dpbase
   237 4B7B 19			dad	d		;hl=,dpbase (diskno*16)
   238 4B7C C9			ret
   239 			;
   240 			settrk:	;set track given by register c
   241 4B7D 79			mov	a, c
   242 4B7E 32 E9 4C		sta	track
   243 4B81			ds	10h		;space for track select
   244 4B91 C9			ret
   245 			;
   246 			setsec:	;set sector given by register c
   247 4B92 79			mov	a, c
   248 4B93 32 EB 4C		sta	sector
   249 4B96			ds	10h		;space for sector select
   250 4BA6 C9			ret
   251 			;
   252 			;
   253 			sectran:
   254 				;translate the sector given by bc using the
   255 				;translate table given by de
   256 4BA7 EB			xchg			;hl=.trans
   257 4BA8 09			dad	b		;hl=.trans (sector)
   258 4BA9 6E			mov	l, m		;l=trans (sector)
   259 4BAA 26 00		mvi	h, 0		;hl=trans (sector)
   260 4BAC C9			ret			;with value in hl
   261 			;
   262 			setdma:	;set	dma address given by registers b and c
   263 4BAD 69			mov	l, c		;low order address
   264 4BAE 60			mov	h, b		;high order address
   265 4BAF 22 ED 4C		shld	dmaad		;save the address
   266 4BB2			ds	10h		;space for setting the dma address
   267 4BC2 C9			ret
   268 			;
   269 			read:	;perform read operation (usually this is similar to write
   270 			;	so we will allow space to set up read command, then use
   271 			;	common code in write)
   272 4BC3			ds	10h		;set up read command
   273 4BD3 C3 E6 4B		jmp	waitio		;to perform the actual i/o
   274 			;
   275 			write:	;perform a write operation
   276 4BD6			ds	10h		;set up write command
   277 			;
   278 			waitio:	;enter	here from read	and write to perform the actual i/o
   279 			;	operation. return a 00h in register a if the operation completes
   280 			;	properly, and 0lh if an error occurs during the read or write
   281 			;
   282 			;	in this case, we have saved the disk number in 'diskno' (0, 1)
   283 			;			the track number in 'track' (0-76)
   284 			;			the sector number in 'sector' (1-26)
   285 			;			the dma address in 'dmaad' (0-65535)
   286 4BE6			ds	256		;space reserved for i/o drivers
   287 4CE6 3E 01		mvi	a, 1		;error condition
   288 4CE8 C9			ret			;replaced when filled-in
   289 			;
   290 			;	the remainder of the cbios is reserved uninitialized
   291 			;	data area, and does not need to be a Part of the
   292 			;	system	memory image (the space must be available,
   293 			;	however, between"begdat" and"enddat").
   294 			;
   295 4CE9		track:	ds	2		;two bytes for expansion
   296 4CEB		sector:	ds	2		;two bytes for expansion
   297 4CED		dmaad:	ds	2		;direct memory address
   298 4CEF		diskno:	ds	1		;disk number 0-15
   299 			;
   300 			;	scratch ram area for bdos use
   301      4C F0	begdat	equ	$	 	;beginning of data area
   302 4CF0		dirbf:	ds	128	 	;scratch directory area
   303 4D70		all00:	ds	31	 	;allocation vector 0
   304 4D8F		all01:	ds	31	 	;allocation vector 1
   305 4DAE		all02:	ds	31	 	;allocation vector 2
   306 4DCD		all03:	ds	31	 	;allocation vector 3
   307 4DEC		chk00:	ds	16		;check vector 0
   308 4DFC		chk01:	ds	16		;check vector 1
   309 4E0C		chk02:	ds	16	 	;check vector 2
   310 4E1C		chk03:	ds	16	 	;check vector 3
   311 			;
   312      4E 2C	enddat	equ	$	 	;end of data area
   313      01 3C	datsiz	equ	$-begdat;	;size of data area
   314     			end


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names		Types	Values
-----		-----	------
msize		EQU	00014h
bias		EQU	00000h
ccp		EQU	03400h
bdos		EQU	03C06h
bios		EQU	04A00h
cdisk		EQU	00004h
iobyte		EQU	00003h
nsects		EQU	0002Ch
begdat		EQU	04CF0h
enddat		EQU	04E2Ch
datsiz		EQU	0013Ch
wboote		Label	04A03h
dpbase		Label	04A33h
trans		Label	04A73h
dpblk		Label	04A8Dh
boot		Label	04A9Ch
wboot		Label	04AA6h
load1		Label	04ABAh
gocpm		Label	04AEFh
const		Label	04B11h
conin		Label	04B24h
conout		Label	04B37h
list		Label	04B49h
listst		Label	04B4Bh
punch		Label	04B4Dh
reader		Label	04B4Fh
home		Label	04B54h
seldsk		Label	04B5Ah
settrk		Label	04B7Dh
setsec		Label	04B92h
sectran		Label	04BA7h
setdma		Label	04BADh
read		Label	04BC3h
write		Label	04BD6h
waitio		Label	04BE6h
track		Label	04CE9h
sector		Label	04CEBh
dmaad		Label	04CEDh
diskno		Label	04CEFh
dirbf		Label	04CF0h
all00		Label	04D70h
all01		Label	04D8Fh
all02		Label	04DAEh
all03		Label	04DCDh
chk00		Label	04DECh
chk01		Label	04DFCh
chk02		Label	04E0Ch
chk03		Label	04E1Ch

Statistics
----------
"Name"	= 0
"EQU"	= 11
"SET"	= 0
Labels	= 37


