* live-coding

This is the project I will use for live-coding.

** Project Goal

The goal of this project is to use Old School software engineering
techniques to build a Discrete Event Simulation of an Old School small
computer system.

** Character Set: UTF-8 encoding of UNICODE

I suggest installing Fira Code, or some variant; then configuring your
editing system to enable Ligature support. While I will be sticking
with plain ASCII for program text, I will freely use greek letters and
special symbols in comments, string literals, and documentation.

- 1 μs is a microsecond.
- Δτ is an elapsed time.

At a minimum, be sure you can read the above. Having greek letters in
your font is sufficient.

** Programming Language: C99 with GNU extensions.

This project is intended to be Old School Coding; it will be
written to the ISO/IEC 9899:1999 standard, also known as C99, with
selected GNU GCC extensions.

** Testing Philosophy

I believe in test-as-you-go as a tool that helps me achieve and
maintain appropriate code correctness and performance. Some tests run
and must pass for a build to be successful. Some tests run every time
you run the program. Some tests are run on demand, which take longer
but perform deeper and more complicated testing.

** Build Tools

I use shell scripting to trigger my builds, and GNU Make to do the
build commands; this gives me a level of build system flexibility
beyond what I have been able to achieve with other tools.

** Editing Environment

I edit in GNU Emacs, and typically have an Xterm open on the side that
runs scripts that run the build and test system.

* Code Tour from Bottom to Top

** headers: include the Standard C headers I expect to need

This most but not all of the headers in the C99 standard.

True "Old School" code would only include, in each .c file,
the exact headers needed by that file; failure to do so would
have caused build times to grow large.

** support: the rock below our feet (including rtc and tau)

This is a "catch all" for support code imported into the project
before starting on the project itself. This includes typedefs for
convenience types like "Cstr" and "Tau", declarations for utility
functions like "format", and the interface to bedrock facilities such
as "tau" and "rtc", and improved debug macros such as "STUB", "FAIL",
and "ASSERT".

** rtc: real time clock (host system wall-clock elapsed time)

Provide methods for callers to obtain the advertised precision
of the elapsed time measurements; and to obtain the elapsed time
since an arbitrary starting point.

** step: a function to call, and a pointer to pass it.

A trivial data structure but one that is going to be used in some of
the most time critical code in this system. This mainly exists as a
separate entity as an exercise and a way to improve the development
process, but knowing it works and how fast it works is helpful.

** stepat: a function to call, a pointer to pass it, and a Tau.

This is also nearly trivial, and nearly identical to step; it adds a
field indicating what the simulation TAU should be when the function
is called. The method that activates the stepat is similar to the
method in step, with the addition that it sets TAU before calling
the target function.

** subs: a place for things to do

This structure accumulates steps to be called, and allows a caller to
trigger all of those steps. Subscribers should be added during
initialization of each significant facility using subs.

** fifo: a place for things to do next

This facility allows a caller to append an entry to a list of things
to do; to run the next entry on the list; and to run entries from
the list until it is empty. Entries are called in the order they were
added to the list.

** sched: a place for things to do in order

This facility allows a caller to schedule a call to be made at a
specific simulation time; to run an item from the schedule; and to run
items from the schedule until it is empty. Entries are activated in
ascending TAU order. If two entries have the same TAU value, it is
UNDEFINED which will be activated first.

** main: program entry point

- Runs POST methods.
- On request, runs BIST methods.
- On request, runs BENCH methods.
