* live-coding

This is the project I will use for live-coding.

** Project Goal

The goal of this project is to use Old School software engineering
techniques to build a Discrete Event Simulation of an Old School small
computer system.

This is not a redesign of Verilog or Spice. Huzzah!

For all simulated items, the simuliation will differ from the hardware
in that signal rise and fall times are fixed at 0 ns (where in real
life, rise and fall times are several nanoseconds). Additionally, with
very few exceptions, the rising and falling edges of generated signals
will be at the same time as the rising edge of the primary CLOCK
signal within the simualtion.

** Character Set: UTF-8 encoding of UNICODE

I suggest installing Fira Code, or some variant; then configuring your
editing system to enable Ligature support. While I will be sticking
with plain ASCII for program text, I will freely use greek letters and
special symbols in comments, string literals, and documentation.

- 1 μs is a microsecond.
- Δτ is an elapsed time.

At a minimum, be sure you can read the above. Having greek letters in
your font is sufficient.

** Programming Language: C99 with GNU extensions.

This project is intended to be Old School Coding; it will be
written to the ISO/IEC 9899:1999 standard, also known as C99, with
selected GNU GCC extensions.

** Testing Philosophy

I believe in test-as-you-go as a tool that helps me achieve and
maintain appropriate code correctness and performance. Some tests run
and must pass for a build to be successful. Some tests run every time
you run the program. Some tests are run on demand, which take longer
but perform deeper and more complicated testing.

** Build Tools

I use shell scripting to trigger my builds, and GNU Make to do the
build commands; this gives me a level of build system flexibility
beyond what I have been able to achieve with other tools.

** Editing Environment

I edit in GNU Emacs, and typically have an Xterm open on the side that
runs scripts that run the build and test system.

* Code Tour from Bottom to Top

** headers: include the Standard C headers I expect to need

This most but not all of the headers in the C99 standard.

True "Old School" code would only include, in each .c file,
the exact headers needed by that file; failure to do so would
have caused build times to grow large.

** support: the rock below our feet (including rtc and tau)

This is a "catch all" for support code imported into the project
before starting on the project itself. This includes typedefs for
convenience types like "Cstr" and "Tau", declarations for utility
functions like "format", and the interface to bedrock facilities such
as "tau" and "rtc", and improved debug macros such as "STUB", "FAIL",
and "ASSERT".

** rtc: real time clock (host system wall-clock elapsed time)

Provide methods for callers to obtain the advertised precision
of the elapsed time measurements; and to obtain the elapsed time
since an arbitrary starting point.

** step: a function to call, and a pointer to pass it.

A trivial data structure but one that is going to be used in some of
the most time critical code in this system. This mainly exists as a
separate entity as an exercise and a way to improve the development
process, but knowing it works and how fast it works is helpful.

** stepat: a function to call, a pointer to pass it, and a Tau.

This is also nearly trivial, and nearly identical to step; it adds a
field indicating what the simulation TAU should be when the function
is called. The method that activates the stepat is similar to the
method in step, with the addition that it sets TAU before calling
the target function.

** subs: a place for things to do

This structure accumulates steps to be called, and allows a caller to
trigger all of those steps. Subscribers should be added during
initialization of each significant facility using subs.

** fifo: a place for things to do next

This facility allows a caller to append an entry to a list of things
to do; to run the next entry on the list; and to run entries from
the list until it is empty. Entries are called in the order they were
added to the list.

** sched: a place for things to do in order

This facility allows a caller to schedule a call to be made at a
specific simulation time; to run an item from the schedule; and to run
items from the schedule until it is empty. Entries are activated in
ascending TAU order. If two entries have the same TAU value, it is
UNDEFINED which will be activated first.

** edge: a signal with callbacks for rising and falling edges

This facility tracks the value of a signal in the simulated system,
and triggers callbacks on rising and falling edges. It has built-in
protection against infinite recursion (where the value of the edge is
changed during a callback), and detection of some hazards.

Each edge is "owned" either by a single simulation module, or by the
simulation environment as a whole. The full formal name of an edge is
the name of the module that owns it, combined with the name given to
that signal in the reference sheet for the simulated item; the two
parts are separated by a colon.

Modules are often "owned" by other modules; their names follow the
same conventions, with the name of the owning module, a colon, and the
name that the owning module uses for the owned module.

Greek characters in signal names will be used in the name string of
the edge as-is, but must be written out when the symbol name occurs as
a C identifier. Similarly, signals that are active-low are represented
on diagrams with a line above their name. The C identifier is the name
with a single underscore appended; add a "/" to the start to construct
the display name.

** clock: provide an Edge that oscillates

This facility provides an Edge, a function that cause it to oscillate
between high and low, and functions that relate cycles of this CLOCK
to the simulation time.

** timing: check simulated signal timing

This facility verifies that the elapsed time from a start call to a
final call is within a specified range. The duration of the interval
is checked when the end of an interval is noted, and the start of the
interval is present. The timing checker will terminate the run if it
sees an interval with a bad duration.

A summary can be printed for each checker, and a final check can be
made that the range of values, converted to nanoseconds, is within the
originally requested range, as the runtime checks are done in terms of
TAU counts with limits computed from the requested durations.

** Main: program entry point

- Runs POST methods.
- On request, runs BIST methods.
- On request, runs BENCH methods.
  
* Simulated Systems

** A hypothetical 8080 based microcomputer

This is the first simulation being considered, and will be a rough
collection of components described in:

    Intel 8080 Microcomputer Systems User's Manual
    September 1975

This document is available from several source on the Internet;
On 14 Sep 2023 I fetched this 43049640-byte document from:

    http://bitsavers.trailing-edge.com/components/intel/MCS80/98-153B_Intel_8080_Microcomputer_Systems_Users_Manual_197509.pdf

I also have in my archives a 42838473-byte version with the same content,
but I did not record where it came from; while the size differs, it has the
same hand-written annotation.

*** i8224: Clock Generator and Driver for 8080A CPU

This module expects to see rising edges on its OSC input. Based on
these edges, it constructs a two-phase clock; it synchronizes RESET
and READY to a specific phase of the clock; and generates /STSTB, when
SYNC is active, with appropriate timing.

*** i8228: System Controller and Bus Driver 8080A CPU

This module expects to see a status strobe, during which time
the Data bus contains status bits. Based the latched value of
those status bits, the control signals are asserted at the
correct time (when enabled).

Timing is similar to the 8228 (but quantized).

