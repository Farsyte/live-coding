* live-coding

This is the project I will use for live-coding.

** Project Goal

The goal of this project is to use Old School software engineering
techniques to build a Discrete Event Simulation of an Old School small
computer system.

** Character Set: UTF-8 encoding of UNICODE

I suggest installing Fira Code, or some variant; then configuring your
editing system to enable Ligature support. While I will be sticking
with plain ASCII for program text, I will freely use greek letters and
special symbols in comments, string literals, and documentation.

- 1 μs is a microsecond.
- Δτ is an elapsed time.

At a minimum, be sure you can read the above. Having greek letters in
your font is sufficient.

** Programming Language: C99 with GNU extensions.

This project is intended to be Old School Coding; it will be
written to the ISO/IEC 9899:1999 standard, also known as C99, with
selected GNU GCC extensions.

** Testing Philosophy

I believe in test-as-you-go as a tool that helps me achieve and
maintain appropriate code correctness and performance. Some tests run
and must pass for a build to be successful. Some tests run every time
you run the program. Some tests are run on demand, which take longer
but perform deeper and more complicated testing.

** Build Tools

I use shell scripting to trigger my builds, and GNU Make to do the
build commands; this gives me a level of build system flexibility
beyond what I have been able to achieve with other tools.

** Editing Environment

I edit in GNU Emacs, and typically have an Xterm open on the side that
runs scripts that run the build and test system.

* Code Tour from Bottom to Top

** support: the rock below our feet (including rtc and tau)

This is a "catch all" for the sort of minor macros and facilities that
end up being helpful during development, or have grown from such need
in the past. This tends to have stuff I have "passed down" from project
to project over time.

Typedefs for "awkward" types; for example, in modern C, if you want to
pass around a pointer to a string literal, "const char *" is the
magical incantation. I provide a "Cstr" typedef, which not only
encapsulates the use of const, but also advertises that we expect the
string to end with an ASCII NUL character (a zero byte).

Typedefs that encapsulate porting decisions, because I will always be
mindful of the issues surrounding movement between platforms that do
not agree on sizes of pointers, or longs, or ints.

In this case, I include the "Tau" type, which represents a value that
monotonically increases over time, and must not wrap around during the
course of a normal program run.

Support for string operations is minimal, so additional operations end
up here as well. For now, I'm just using "format(fmt, ...)" which uses
a printf-style format string to format a bunch of data items, into a
string that is dynamically allocated. Caller must retain the pointer
or free the memory, or there will be a leak.

Macros for producing output -- single lines, such as the ones
indicating entry into or exit from a facility, or more interesting
ones that generate arbitrary messages that include the filename, line
number, and function name; a variant that calls "abort" after doing so
to simplify the trivial reporting of a fatal problem.

Macros in support of testing. ASSERT(cond, ...) adds printing of a
useful message to the otherwise terse C "assert(cond)" macro; and
additional versions like "ASSERT_EQ_integer(exp, obs)" which handle
working out what the additional useful text should be.

Benchmarking support in the form of an RTC package, providing rtc_ns()
for elapsed time computation, and rtc_elapsed() for benchmarking.

** step: a function to call, and a pointer to pass it.

A trivial data structure but one that is going to be used in some of
the most time critical code in this system. This mainly exists as a
separate entity as an exercise and a way to improve the development
process, but knowing it works and how fast it works is helpful.

** stepat: a step with an associated simulation tau

This is also nearly trivial, and nearly identical to step; it adds a
field indicating what the simulation TAU should be when the function
is called.

** subs: a list of steps that can be extended and executed

This structure accumulates steps to be called, and allows a caller to
trigger all of those steps. Subscribers should be added during
initialization of the significant facility using subs.

