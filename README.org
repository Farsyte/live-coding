* live-coding

This is the project I will use for live-coding.

** Project Goal

The goal of this project is to use Old School software engineering
techniques to build a Discrete Event Simulation of an Old School small
computer system.

This is not a redesign of Verilog or Spice. Huzzah!

For all simulated items, the simuliation will differ from the hardware
in that signal rise and fall times are fixed at 0 ns (where in real
life, rise and fall times are several nanoseconds). Additionally, with
very few exceptions, the rising and falling edges of generated signals
will be at the same time as the rising edge of the primary CLOCK
signal within the simualtion.

** Character Set: UTF-8 encoding of UNICODE

I suggest installing Fira Code, or some variant; then configuring your
editing system to enable Ligature support. While I will be sticking
with plain ASCII for program text, I will freely use greek letters and
special symbols in comments, string literals, and documentation.

- 1 μs is a microsecond.
- Δτ is an elapsed time.
- Φ₁ is the phase-1 clock.

At a minimum, be sure you can read the above. Having greek letters in
your font is sufficient.

** Programming Language: C99 with GNU extensions.

This project is intended to be Old School Coding; it will be
written to the ISO/IEC 9899:1999 standard, also known as C99, with
selected GNU GCC extensions.

** Testing Philosophy

I believe in test-as-you-go as a tool that helps me achieve and
maintain appropriate code correctness and performance. Some tests run
and must pass for a build to be successful. Some tests run every time
you run the program. Some tests are run on demand, which take longer
but perform deeper and more complicated testing.

** Build Tools

I use shell scripting to trigger my builds, and GNU Make to do the
build commands; this gives me a level of build system flexibility
beyond what I have been able to achieve with other tools.

** Editing Environment

I edit in GNU Emacs, and typically have an Xterm open on the side that
runs scripts that run the build and test system.

** Signal Display

A python script "bin/timing.py" handles conversion of logged timing
data into WaveJSON and rendering it using "schemdraw", giving PNG
files that can be included in documentation.

For more information on WaveJSON, WaveDrom, and schemdraw, see:

[[https://github.com/RonSheely/schemdraw]]
[[https://schemdraw.readthedocs.io]]
[[https://wavedrom.com/]]
[[https://github.com/wavedrom/wavedrom/wiki/WaveJSON]]

#+begin_src text
  $ pip install 'schemdraw[matplotlib]'
#+end_src

*** Timing Plot Definitions: log/timing/{name}.txt

These text files describe the construction of a timing plot, with
the lines containing:

- Title of the plot, printed at the top of the plot.
- Caption of the plot, printed at the bottom of the plot.
- The "session name" where the data can be found
- Minimum TAU for the plot, and width of the plot in TAU units

Following those four required lines are the lines containing the names
of the signals to include. Simple rules are used to convert these
names into nice labels and into the names of the files containing the
data.

- Trailing underbar and leading slash indicate an "active low" signal.
  These are discarded when building the filename, and are converted to
  an "overline" when rendering the label.

- The first underbar (if any) indicates that the remainder of the
  string is a subscript. This causes no change in the trace file name.
  Appropriate annotations are made when plotting to obtain the
  subscript effect.

- A leading backslash indicates that the signal name starts with a
  special character such as Φ. The backslash is stripped when
  constructing the filename, and is passed along to the label
  rendering engine.

Examples:

- "\Phi_1" uses "Phi_1" in the filename, and "Φ₁" as the label for the
  row of the graph (rendered properly, not just using the Unicode
  characters from this document).

- "/STSTB" uses "STSTB" in the filename, and "STSTB" with a line over
  it as the label (the UNICODE COMBINING OVERBAR over each character
  does not do this justice).

*** Trace Data Records: log/timing/{session}/{signal}.log

These files contain TAU values, and signal values in the form defined
for the "wave" field of WaveJSON as extened by schemdraw. Generally
data are presented as a sequence of signal values, associated with
an incrementing tau. A new tau is set by placing the new tau value
at the start of a line, followed by a colon.

Some of the signal codes are used to represent multibit data, and
require text to place on the plot. This text follows the signal
code and extends to the next newline.

**** Some of the signal wave codes:

- 'p': positive edged clock wave (P adds an arrow on the rising edge)
- 'n': negative edged clock wave (N adds an arrow on the falling edge)
- '0': signal value is 0 or "low"
- '1': signal value is 1 or "high"

- 'z': high impedence state
- 'x': unknown state
- 'u': pull-up
- 'd': pull-down
- '.': extend previous cycle
- '|': extend previous cycle and draw a gap on it

- '=': multibyte data, default color
- '2': multibyte data, color 2
- '3': multibyte data, color 3
- '4': multibyte data, color 4
- '5': multibyte data, color 5
- '6': multibyte data, color 6
- '7': multibyte data, color 7
- '8': multibyte data, color 8
- '9': multibyte data, color 9

* PENDING ITEMS
** TODO create more pending items
* Code Tour from Bottom to Top

** headers: include the Standard C headers I expect to need

This most but not all of the headers in the C99 standard.

True "Old School" code would only include, in each .c file,
the exact headers needed by that file; failure to do so would
have caused build times to grow large.

** support: the rock below our feet (including rtc and tau)

This is a "catch all" for support code imported into the project
before starting on the project itself. This includes typedefs for
convenience types like "Cstr" and "Tau", declarations for utility
functions like "format", and the interface to bedrock facilities such
as "tau" and "rtc", and improved debug macros such as "STUB", "FAIL",
and "ASSERT".

** rtc: real time clock (host system wall-clock elapsed time)

Provide methods for callers to obtain the advertised precision
of the elapsed time measurements; and to obtain the elapsed time
since an arbitrary starting point.

** step: a function to call, and a pointer to pass it.

A trivial data structure but one that is going to be used in some of
the most time critical code in this system. This mainly exists as a
separate entity as an exercise and a way to improve the development
process, but knowing it works and how fast it works is helpful.

** stepat: a function to call, a pointer to pass it, and a Tau.

This is also nearly trivial, and nearly identical to step; it adds a
field indicating what the simulation TAU should be when the function
is called. The method that activates the stepat is similar to the
method in step, with the addition that it sets TAU before calling
the target function.

** subs: a place for things to do

This structure accumulates steps to be called, and allows a caller to
trigger all of those steps. Subscribers should be added during
initialization of each significant facility using subs.

** fifo: a place for things to do next

This facility allows a caller to append an entry to a list of things
to do; to run the next entry on the list; and to run entries from
the list until it is empty. Entries are called in the order they were
added to the list.

** sched: a place for things to do in order

This facility allows a caller to schedule a call to be made at a
specific simulation time; to run an item from the schedule; and to run
items from the schedule until it is empty. Entries are activated in
ascending TAU order. If two entries have the same TAU value, it is
UNDEFINED which will be activated first.

** edge: a signal with callbacks for rising and falling edges

This facility tracks the value of a signal in the simulated system,
and triggers callbacks on rising and falling edges. It has built-in
protection against infinite recursion (where the value of the edge is
changed during a callback), and detection of some hazards.

Each edge is "owned" either by a single simulation module, or by the
simulation environment as a whole. The full formal name of an edge is
the name of the module that owns it, combined with the name given to
that signal in the reference sheet for the simulated item; the two
parts are separated by a colon.

Modules are often "owned" by other modules; their names follow the
same conventions, with the name of the owning module, a colon, and the
name that the owning module uses for the owned module.

Greek characters in signal names will be used in the name string of
the edge as-is, but must be written out when the symbol name occurs as
a C identifier. Similarly, signals that are active-low are represented
on diagrams with a line above their name. The C identifier is the name
with a single underscore appended; add a "/" to the start to construct
the display name.

** addr: a signal bus with callbacks for changes in state.

This facility tracks the value of an address bus in the simulated
system, and triggers callbacks on change in state. It has built-in
protection against infinite recursion (where the value of the addr
is changed during a callback), and detection of some hazards.

The state of the bus includes an implicit "Z" (high impedence)
state where a transition to "Z" can be followed by a valid value
within the same TAU.

This facility exists to support display and validation of the
timing of signals. Callbacks on bus valid and bus "Z" can be used
to record transitions into a trace, but should not be used to drive
simulation logic.

** data: a signal bus with callbacks for changes in state.

This facility tracks the value of an dataess bus in the simulated
system, and triggers callbacks on change in state. It has built-in
protection against infinite recursion (where the value of the data
is changed during a callback), and detection of some hazards.

The state of the bus includes an implicit "Z" (high impedence)
state where a transition to "Z" can be followed by a valid value
within the same TAU.

This facility exists to support display and validation of the
timing of signals. Callbacks on bus valid and bus "Z" can be used
to record transitions into a trace, but should not be used to drive
simulation logic.

** clock: provide an Edge that oscillates

This facility provides an Edge, a function that cause it to oscillate
between high and low, and functions that relate cycles of this CLOCK
to the simulation time.

** timing: check simulated signal timing

This facility verifies that the elapsed time from a start call to a
final call is within a specified range. The duration of the interval
is checked when the end of an interval is noted, and the start of the
interval is present. The timing checker will terminate the run if it
sees an interval with a bad duration.

A summary can be printed for each checker, and a final check can be
made that the range of values, converted to nanoseconds, is within the
originally requested range, as the runtime checks are done in terms of
TAU counts with limits computed from the requested durations.

** hex: parse the content of a hex file

Intel HEX format files provide a way, using somewhat readable plain
text, to store and transfer blobs of binary data. Each line defines a
small amount of data, explicitly giving its address, with a checksum
to protect against transmission errors.

** main: program entry point

- Runs POST methods.
- On request, runs BIST methods.
- On request, runs BENCH methods.
  
* Simulated Systems

** A hypothetical 8080 based microcomputer

This is the first simulation being considered, and will be a rough
collection of components described in:

    Intel 8080 Microcomputer Systems User's Manual
    September 1975

This document is available from several source on the Internet;
On 14 Sep 2023 I fetched this 43049640-byte document from:

    http://bitsavers.trailing-edge.com/components/intel/MCS80/98-153B_Intel_8080_Microcomputer_Systems_Users_Manual_197509.pdf

I also have in my archives a 42838473-byte version with the same content,
but I did not record where it came from; while the size differs, it has the
same hand-written annotation.

*** i8224: Clock Generator and Driver for 8080A CPU

This module expects to see rising edges on its OSC input. Based on
these edges, it constructs a two-phase clock; it synchronizes RESET
and READY to a specific phase of the clock; and generates /STSTB, when
SYNC is active, with appropriate timing.

*** i8228: System Controller and Bus Driver 8080A CPU

This module expects to see a status strobe, during which time
the Data bus contains status bits. Based the latched value of
those status bits, the control signals are asserted at the
correct time (when enabled).

Timing is similar to the 8228 (but quantized).

*** decoder: efficient enables for mem pages and i/o ports

This module monitors the control bus and the address bus,
triggering edges registered for each page of memory and
each I/O port, separately for read and write, to avoid the
performance issues around having every memory and device
monitoring DBIN and/or /WR.

